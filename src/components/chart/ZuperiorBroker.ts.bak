import {
	AccountId,
	AccountManagerInfo,
	AccountMetainfo,
	ActionMetaInfo,
	Brackets,
	CellAlignment,
	CommonAccountManagerColumnId,
	ConnectionStatus,
	DefaultContextMenuActionsParams,
	Execution,
	IBrokerConnectionAdapterHost,
	IDelegate,
	IndividualPosition,
	InstrumentInfo,
	IsTradableResult,
	ISubscription,
	IWatchedValue,
	MenuSeparator,
	Order,
	OrderStatus,
	OrderType,
	ParentType,
	PlaceOrderResult,
	Position,
	PreOrder,
	Side,
	StandardFormatterName,
} from '../../../public/charting_library/broker-api';

import { IDatafeedQuotesApi, QuoteData } from '../../../public/charting_library/datafeed-api';
import { AbstractBrokerMinimal } from './abstract-broker-minimal';
import { apiClient } from '../../lib/api';

class SimpleSubscription<TFunc extends Function> implements ISubscription<TFunc> {
	private _listeners: TFunc[] = [];
	public subscribe(listener: TFunc): void {
		this._listeners.push(listener);
	}
	public unsubscribe(listener: TFunc): void {
		const index = this._listeners.indexOf(listener);
		if (index > -1) {
			this._listeners.splice(index, 1);
		}
	}
	public unsubscribeAll(obj: object | null): void {
		this._listeners = [];
	}
	public fire(...args: any[]): void {
		this._listeners.forEach(listener => {
			if (typeof listener === 'function') {
				// @ts-ignore
				listener(...args);
			}
		});
	}
}

import {
	loginDirect,
	getPositionsDirect,
	getPendingOrdersDirect,
	getAccountBalanceDirect,
	closePositionDirect,
	placeMarketOrderDirect,
	placePendingOrderDirect,
	cancelPendingOrderDirect,
	modifyPositionDirect,
	modifyPendingOrderDirect
} from '../../lib/metaapi';

interface SimpleMap<TValue> {
	[key: string]: TValue;
}

interface ApiPosition {
	id: string;
	ticket: number;
	symbol: string;
	type: 'Buy' | 'Sell' | 'Buy Limit' | 'Sell Limit' | 'Buy Stop' | 'Sell Stop';
	volume: number;
	openPrice: number;
	currentPrice: number;
	takeProfit?: number;
	stopLoss?: number;
	profit: number;
	orderType?: number;
}

// Helper function to change side (Buy <-> Sell)
function changeSide(side: Side): Side {
	return side === Side.Buy ? Side.Sell : Side.Buy;
}

// Safe host call wrapper
function safeHostCall(host: any, method: string, ...args: any[]): any {
	try {
		if (host && typeof host[method] === 'function') {
			return host[method](...args);
		}
	} catch (e) {
		// Host call failed - silently handle
	}
	return undefined;
}

const PREVIEW_ORDER_ID = 'PREVIEW_ORDER_ID';

export class ZuperiorBroker extends AbstractBrokerMinimal {
	private _accountId: string | null;
	private _positions: Position[] = [];
	private _orders: Order[] = [];
	private _positionById: SimpleMap<Position> = {};
	private _orderById: SimpleMap<Order> = {};
	private _pollInterval: any = null;
	private _isPolling = false;
	private _isWidgetReady = false;
	private _getMetaApiToken: ((accountId: string) => Promise<string | null>) | null = null;
	private _accessToken: string | null = null;
	private _accountBalance: number = 0;
	private _lastActionTime: number = 0; // Timestamp of last user action to pause polling

	private _positionsSubscription = new SimpleSubscription<(data: {}) => void>();
	private _ordersSubscription = new SimpleSubscription<(data: {}) => void>();

	public constructor(
		host: IBrokerConnectionAdapterHost,
		quotesProvider: IDatafeedQuotesApi,
		accountId: string | null,
		getMetaApiToken?: (accountId: string) => Promise<string | null>
	) {
		super(host, quotesProvider);
		this._accountId = accountId;
		this._getMetaApiToken = getMetaApiToken || null;
		// Start fetching immediately so positions()/orders() have data when TradingView queries
		this._startPolling();
	}

	// Method to update token function after broker creation
	public setMetaApiTokenFunction(getMetaApiToken: (accountId: string) => Promise<string | null>) {
		this._getMetaApiToken = getMetaApiToken;
	}

	public setWidgetReady(ready: boolean) {
		this._isWidgetReady = ready;
		if (ready) {
			// When widget becomes ready, trigger updates for all existing positions/orders
			this._notifyAllPositionsAndOrders();
			if (!this._isPolling) {
				this._startPolling();
			}
		}
	}

	public setAccountId(accountId: string | null) {
		if (this._accountId === accountId) return;

		this._accountId = accountId;

		// Clear existing data
		this._positions.length = 0;
		this._orders.length = 0;
		this._positionById = {};
		this._orderById = {};

		// Restart polling with new account
		if (this._isPolling) {
			this._fetchPositionsAndOrders();
		} else {
			this._startPolling();
		}
	}

	private _notifyAllPositionsAndOrders() {
		// Ensure arrays exist before filtering
		if (!Array.isArray(this._orders) || !Array.isArray(this._positions)) {
			return;
		}

		// 1. Update positions FIRST (Matches _fetchPositionsAndOrders flow)
		this._positions.forEach(p => {
			try {
				if (this._host) {
					const cleanPosition = this._createCleanPosition(p);
					// Update _positionById with clean position before calling positionUpdate
					this._positionById[cleanPosition.id] = cleanPosition;

					if (typeof this._host.positionUpdate === 'function') {
						console.log('[ZuperiorBroker] Notifying position update:', cleanPosition);
						this._host.positionUpdate(cleanPosition);
					}

					if ((cleanPosition as any).pl !== undefined && typeof (cleanPosition as any).pl === 'number' && typeof this._host.plUpdate === 'function') {
						this._host.plUpdate(cleanPosition.symbol, (cleanPosition as any).pl);
					}
				}
			} catch (error) {
				console.error('[ZuperiorBroker] Error notifying position:', error, p);
			}
		});

		// CRITICAL: Get bracket orders from _orderById (not _orders) for chart display
		// _orders should only contain real pending orders, bracket orders are in _orderById
		const allOrdersFromMap = Object.values(this._orderById || {});
		const bracketOrders = allOrdersFromMap.filter(o => this._isBracketOrder(o));

		console.log(`[ZuperiorBroker] Notify: Total Orders in Map: ${allOrdersFromMap.length}, Brackets: ${bracketOrders.length}`);
		if (bracketOrders.length === 0 && allOrdersFromMap.length > 0) {
			console.log('[ZuperiorBroker] WARNING: Orders exist but no brackets found. Sample order:', allOrdersFromMap[0]);
			console.log('[ZuperiorBroker] _isBracketOrder check result for sample:', this._isBracketOrder(allOrdersFromMap[0]));
		}

		// Regular orders are in _orders array (already filtered to exclude brackets)
		const regularOrders = this._orders.filter(o => o && !this._isBracketOrder(o));

		// 2. Send bracket orders via orderUpdate() with correct status and parentId/parentType set
		bracketOrders.forEach(bracket => {
			console.log(`[ZuperiorBroker] Processing bracket ${bracket.id} for update`);
			try {
				if (this._host && typeof this._host.orderUpdate === 'function') {
					if (bracket.parentType === undefined) {
						bracket.parentType = ParentType.Position;
					}

					// CRITICAL: Calculate projected P/L at bracket price for correct display
					// CRITICAL: Calculate projected P/L at bracket price for correct display
					if (bracket.parentId) {
						const parentPosition = this._positionById[bracket.parentId];
						const parentOrder = this._orderById[bracket.parentId];

						if (parentPosition) {
							// Ensure parentType is Position
							bracket.parentType = ParentType.Position;

							if (parentPosition.avgPrice) {
								const bracketPrice = (bracket as any).limitPrice || (bracket as any).stopPrice;
								if (bracketPrice) {
									// Calculate using FULL volume (multiply qty by 10000)
									const fullVolume = parentPosition.qty * 10000;
									const priceDiff = bracketPrice - parentPosition.avgPrice;
									const plAtBracket = priceDiff * fullVolume * (parentPosition.side === Side.Sell ? -1 : 1);
									// Multiply by 100 to compensate for TradingView's recalculation
									(bracket as any).pl = plAtBracket * 100;
								} else if ((parentPosition as any).pl !== undefined && (parentPosition as any).pl !== null) {
									(bracket as any).pl = (parentPosition as any).pl * 100;
								}
							} else if ((parentPosition as any).pl !== undefined && (parentPosition as any).pl !== null) {
								(bracket as any).pl = (parentPosition as any).pl * 100;
							}
						} else if (parentOrder) {
							// For order brackets, no P/L calc needed; ensure parentType is Order
							bracket.parentType = ParentType.Order;
						}
					}

					console.log('[ZuperiorBroker] Notifying bracket order update:', bracket);
					this._host.orderUpdate(bracket);
				}
			} catch (error) {
				// Error notifying bracket order - silently handle
			}
		});

		// 3. Update regular orders (for Account Manager)
		regularOrders.forEach(o => {
			try {
				if (this._host && typeof this._host.orderUpdate === 'function') {
					this._host.orderUpdate(o);
				}
			} catch (error) {
				// Error notifying order - silently handle
			}
		});
	}

	private async _ensureAuth() {
		if (!this._accessToken) {
			try {
				if (this._getMetaApiToken && this._accountId) {
					const token = await this._getMetaApiToken(this._accountId);
					if (token) {
						this._accessToken = token;
						// console.log('[ZuperiorBroker] Authenticated successfully with provided token');
						return !!this._accessToken;
					}
				}

				// Fallback to hardcoded dev credentials ONLY if token function fails or not present
				// (Or remove this entirely if strict auth is required)
				/*
				const loginRes = await loginDirect({
					AccountId: 19876892,
					Password: "Test@000",
					DeviceId: "test_device_curl",
					DeviceType: "web"
				});
				if (loginRes.Token) {
					this._accessToken = loginRes.Token;
					console.log('[ZuperiorBroker] Authenticated successfully with MetaAPI Direct (Fallback)');
				}
				*/
			} catch (e) {
				console.error('[ZuperiorBroker] Auth failed', e);
			}
		}
		return !!this._accessToken;
	}

	public connectionStatus(): number {
		return 1; // Connected
	}

	private async _startPolling() {
		if (this._isPolling || !this._accountId) return;
		this._isPolling = true;

		await this._ensureAuth();

		// Initial fetch
		await this._fetchPositionsAndOrders();


		// Poll every 800ms to reduce backend pressure while keeping chart reasonably fresh
		this._pollInterval = setInterval(async () => {
			await this._ensureAuth();
			await this._fetchPositionsAndOrders();
		}, 800);
	}

	private async _fetchPositionsAndOrders(force: boolean = false) {
		// Prevent polling from clobbering optimistic updates unless explicitly forced
		// Reduced window to 1200ms to keep UI fresh while avoiding flicker
		if (!force && Date.now() - this._lastActionTime < 1200) {
			// console.log('[ZuperiorBroker] Skipping poll due to recent user action');
			return;
		}

		if (!this._accountId) {
			return;
		}

		const prevPositions = Array.isArray(this._positions) ? [...this._positions] : [];
		const prevPositionMap: SimpleMap<Position> = { ...this._positionById };
		const prevOrderMap: SimpleMap<Order> = { ...this._orderById };

		let positionsArray: any[] = [];
		let pendingArray: any[] = [];

		// Prefer live data already on the page (same source as Position table) to keep UI in lockstep
		const liveData = (typeof window !== 'undefined' ? (window as any).__LIVE_POSITIONS_DATA__ : null);
		if (liveData) {
			positionsArray = Array.isArray(liveData.openPositions) ? liveData.openPositions : [];
			pendingArray = Array.isArray(liveData.pendingOrders) ? liveData.pendingOrders : [];
		} else if (this._accessToken) {
			try {
				// Use separate calls since combined endpoint is missing in this version
				const [positions, orders] = await Promise.all([
					getPositionsDirect(this._accountId, this._accessToken),
					getPendingOrdersDirect(this._accountId, this._accessToken)
				]);

				positionsArray = positions;
				pendingArray = orders;

			} catch (error: any) {
				// Handle 401 Unauthorized gracefully
				if (error?.status === 401) {
					console.warn('[ZuperiorBroker] 401 Unauthorized - Token expired, will re-auth next poll.');
					this._accessToken = null; // Clear token to force re-auth
					return;
				}
				console.error('[ZuperiorBroker] Error fetching positions/orders:', error);
				return;
			}
		}

		// Map positions - filter out invalid ones
		const tvPositions = (Array.isArray(positionsArray) ? positionsArray : [])
			.map((pos: any) => {
				try {
					return this._mapApiPositionToTVPosition(pos);
				} catch (error) {
					console.error('[ZuperiorBroker] Error mapping position:', error, pos);
					return null;
				}
			})
			.filter((p: Position | null): p is Position => p !== null && !!p.id && !!p.symbol && p.qty > 0 && p.avgPrice > 0);

		// Map pending orders - filter out invalid ones AND bracket orders (TP/SL)
		const tvOrders = (Array.isArray(pendingArray) ? pendingArray : [])
			.map((order: any) => {
				try {
					if (!order || typeof order !== 'object') {
						return null;
					}
					const mappedOrder = this._mapApiOrderToTVOrder(order);
					return mappedOrder;
				} catch (error) {
					console.error('[ZuperiorBroker] Error mapping order:', error, order);
					return null;
				}
			})
			.filter((o: Order | null): o is Order => {
				if (!o || !o.id || !o.symbol) {
					return false;
				}
				// Filter out bracket orders (TP/SL) - they should only be shown as position brackets
				if (o.id && (o.id.includes('TP-') || o.id.includes('SL-'))) {
					return false;
				}
				if (o.status === OrderStatus.Inactive) {
					return false;
				}
				return true;
			});

		// Create bracket orders for positions with TP/SL using helper methods
		const bracketOrders: Order[] = [];
		if (Array.isArray(tvPositions)) {
			tvPositions.forEach(p => {
				// Create TP bracket order if takeProfit is set
				if (p.takeProfit && p.takeProfit > 0 && !isNaN(p.takeProfit) && isFinite(p.takeProfit)) {
					try {
						const tpBracket = this._createTakeProfitBracket(p);
						bracketOrders.push(tpBracket);
					} catch (error) {
						console.error('[ZuperiorBroker] Error creating TP bracket:', error);
					}
				}

				// Create SL bracket order if stopLoss is set
				if (p.stopLoss && p.stopLoss > 0 && !isNaN(p.stopLoss) && isFinite(p.stopLoss)) {
					try {
						const slBracket = this._createStopLossBracket(p);
						bracketOrders.push(slBracket);
					} catch (error) {
						console.error('[ZuperiorBroker] Error creating SL bracket:', error);
					}
				}
			});
		}

		// Create bracket orders for pending orders with TP/SL
		const orderBracketOrders: Order[] = [];
		if (Array.isArray(tvOrders)) {
			tvOrders.forEach(o => {
				if (o.takeProfit && o.takeProfit > 0) {
					try {
						orderBracketOrders.push(this._createOrderTakeProfitBracket(o));
					} catch (e) {
						console.error('[ZuperiorBroker] Error creating order TP bracket:', e);
					}
				}
				if (o.stopLoss && o.stopLoss > 0) {
					try {
						orderBracketOrders.push(this._createOrderStopLossBracket(o));
					} catch (e) {
						console.error('[ZuperiorBroker] Error creating order SL bracket:', e);
					}
				}
			});
		}

		// Combine pending orders with bracket orders
		const allOrders = [
			...(Array.isArray(tvOrders) ? tvOrders : []),
			...bracketOrders,
			...orderBracketOrders
		];

		// Keep preview order and its brackets if they exist in internal state
		Object.keys(this._orderById).forEach(id => {
			if (id.toString().startsWith(PREVIEW_ORDER_ID)) {
				const pOrder = this._orderById[id];
				if (!allOrders.find(o => o.id === pOrder.id)) {
					allOrders.push(pOrder);
				}
			}
		});

		// Build clean positions map
		const cleanPositions: Position[] = [];
		const positionMap: SimpleMap<Position> = {};
		if (Array.isArray(tvPositions)) {
			tvPositions.forEach(p => {
				try {
					const cleanPosition = this._createCleanPosition(p);
					cleanPositions.push(cleanPosition);
					positionMap[cleanPosition.id] = cleanPosition;
				} catch (error) {
					console.error('[ZuperiorBroker] Error creating clean position:', error, p);
				}
			});
		}

		// Update internal state (always)
		this._positions = Array.isArray(tvPositions) ? [...tvPositions] : [];
		// Keep all orders (pending + brackets) so TradingView can track edits/drags
		this._orders = Array.isArray(allOrders) ? [...allOrders] : [];
		this._positionById = positionMap;

		// Update orderById map with ALL orders (including brackets)
		const orderMap: SimpleMap<Order> = {};
		if (Array.isArray(allOrders)) {
			allOrders.forEach(o => {
				if (o && o.id) {
					orderMap[o.id] = o;
				}
			});
		}
		this._orderById = orderMap;

		// Notify Account Manager tables (if subscribed)
		this._positionsSubscription.fire({});
		this._ordersSubscription.fire({});

		// Notify TradingView if widget is ready
		if (this._isWidgetReady) {
			// Step 1: Detect and handle CLOSED positions (Diff against previous state)
			const previousPositionIds = new Set(prevPositions.map(p => p.id));
			const newPositionIds = new Set(cleanPositions.map(p => p.id));

			previousPositionIds.forEach(prevId => {
				if (!newPositionIds.has(prevId)) {
					console.log('[ZuperiorBroker] Detected external close for position:', prevId);
					const closedPosition = prevPositionMap[prevId];
					if (closedPosition && this._host && typeof this._host.positionUpdate === 'function') {
						this._host.positionUpdate({ ...closedPosition, qty: 0, avgPrice: 0 });
					}
				}
			});

			// Notify TradingView with clean positions
			if (cleanPositions.length > 0) {
				cleanPositions.forEach(cleanPosition => {
					try {
						// For positions, we usually notify more frequently for P/L updates
						if (this._host && typeof this._host.positionUpdate === 'function') {
							this._host.positionUpdate(cleanPosition);
						}
						if ((cleanPosition as any).pl !== undefined && typeof (cleanPosition as any).pl === 'number' && this._host && typeof this._host.plUpdate === 'function') {
							this._host.plUpdate(cleanPosition.symbol, (cleanPosition as any).pl);
						}
					} catch (error) {
						console.error('[ZuperiorBroker] Error updating position:', error, cleanPosition);
					}
				});
			}

			// Step 2: Send bracket orders via orderUpdate() ONLY IF CHANGED
			const allBracketOrders = [...bracketOrders, ...orderBracketOrders];
			if (Array.isArray(allBracketOrders) && allBracketOrders.length > 0) {
				allBracketOrders.forEach(bracket => {
					try {
						if (bracket && this._host && typeof this._host.orderUpdate === 'function') {
							// Determine if we should notify
							const prevBracket = prevOrderMap[bracket.id];
							let shouldNotify = !prevBracket;

							if (prevBracket) {
								const newPrice = (bracket as any).limitPrice || (bracket as any).stopPrice;
								const oldPrice = (prevBracket as any).limitPrice || (prevBracket as any).stopPrice;
								if (newPrice !== oldPrice || bracket.qty !== prevBracket.qty || bracket.status !== prevBracket.status) {
									shouldNotify = true;
								}
							}

							if (shouldNotify) {
								if (bracket.parentType === undefined) {
									bracket.parentType = ParentType.Position;
								}

								// CRITICAL: Calculate projected P/L at bracket price
								if (bracket.parentId) {
									const parentPosition = this._positionById[bracket.parentId];
									const parentOrder = this._orderById[bracket.parentId];

									// Use position if parent is a position, otherwise order price as reference
									if (parentPosition && parentPosition.avgPrice) {
										const bracketPrice = (bracket as any).limitPrice || (bracket as any).stopPrice;
										if (bracketPrice && parentPosition.avgPrice) {
											const fullVolume = parentPosition.qty * 10000;
											const priceDiff = bracketPrice - parentPosition.avgPrice;
											const plAtBracket = priceDiff * fullVolume * (parentPosition.side === Side.Sell ? -1 : 1);
											(bracket as any).pl = plAtBracket * 100;
										} else if ((parentPosition as any).pl !== undefined && (parentPosition as any).pl !== null) {
											(bracket as any).pl = (parentPosition as any).pl * 100;
										}
									} else if (parentOrder) {
										// For order brackets, no P/L calc needed; ensure parentType is Order
										bracket.parentType = ParentType.Order;
									}
								}

								this._host.orderUpdate(bracket);
							}
						}
					} catch (error) {
						console.error('[ZuperiorBroker] Error updating bracket order:', error, bracket);
					}
				});
			}

			// Step 3: Update pending orders ONLY IF CHANGED
			if (Array.isArray(tvOrders)) {
				tvOrders.forEach(o => {
					try {
						if (o && this._host && typeof this._host.orderUpdate === 'function') {
							const prevOrder = prevOrderMap[o.id];
							let shouldNotify = !prevOrder;

							if (prevOrder) {
								if (o.limitPrice !== prevOrder.limitPrice || o.stopPrice !== prevOrder.stopPrice || o.qty !== prevOrder.qty || o.status !== prevOrder.status) {
									shouldNotify = true;
								}
							}

							if (shouldNotify) {
								this._host.orderUpdate(o);
							}
						}
					} catch (error) {
						console.error('[ZuperiorBroker] Error updating order:', error, o);
					}
				});
			}

			// Step 4: Cancel removed orders (including brackets)
			const newOrderIds = new Set(Object.keys(orderMap));
			Object.keys(prevOrderMap).forEach(prevId => {
				if (!newOrderIds.has(prevId)) {
					const removedOrder = prevOrderMap[prevId];
					if (removedOrder && this._host && typeof this._host.orderUpdate === 'function') {
						this._host.orderUpdate({ ...removedOrder, status: OrderStatus.Canceled });
					}
				}
			});
		}
	}

	private _mapApiPositionToTVPosition(apiPos: any): Position {
		const ticket = apiPos.ticket || apiPos.Ticket || apiPos.PositionId || apiPos.id;
		const id = String(ticket);

		// API uses Action field: 0 = Buy, 1 = Sell
		const action = apiPos.Action !== undefined ? apiPos.Action : (apiPos.action !== undefined ? apiPos.action : undefined);
		const typeStr = (apiPos.type || apiPos.Type || '').toString();

		let isBuy = false;

		// Priority 1: Check Action field (0 = Buy, 1 = Sell)
		if (action !== undefined) {
			isBuy = action === 0 || String(action) === '0';
		}
		// Priority 2: Check type string
		else if (typeStr === 'Buy') {
			isBuy = true;
		} else if (typeStr === 'Sell') {
			isBuy = false;
		} else {
			isBuy = typeStr.toLowerCase().includes('buy');
		}

		const side = isBuy ? Side.Buy : Side.Sell;

		const openPrice = Number(apiPos.openPrice || apiPos.OpenPrice || apiPos.PriceOpen || apiPos.priceOpen || apiPos.price || apiPos.Price || 0);
		const currentPrice = Number(apiPos.currentPrice || apiPos.CurrentPrice || apiPos.PriceCurrent || apiPos.priceCurrent || apiPos.price || apiPos.Price || openPrice);

		const rawVolume = apiPos.volume || apiPos.Volume || apiPos.units || 0;
		const volumeLots = apiPos.volumeLots || apiPos.VolumeLots;

		let volume: number;

		if (volumeLots !== undefined && volumeLots !== null) {
			volume = Number(volumeLots);
		} else {
			const numVolume = Math.abs(Number(rawVolume));
			volume = numVolume / 10000;
		}

		const profit = Number(apiPos.profit || apiPos.Profit || apiPos.pl || apiPos.PL || 0);

		const symbol = apiPos.symbol || apiPos.Symbol || '';

		return {
			id: id,
			symbol: symbol,
			qty: volume,
			side: side, // Numeric enum for chart rendering (Side.Buy = 1, Side.Sell = -1)
			sideText: isBuy ? 'Buy' : 'Sell', // String for Account Manager display
			avgPrice: openPrice,
			takeProfit: Number(apiPos.takeProfit || apiPos.TakeProfit || apiPos.PriceTP || apiPos.TP || apiPos.tp || 0) || undefined,
			stopLoss: Number(apiPos.stopLoss || apiPos.StopLoss || apiPos.PriceSL || apiPos.SL || apiPos.sl || 0) || undefined,
			profit: profit, // For Account Manager display
			pl: profit, // For chart trade line P/L display
			text: " ",
		} as any;
	}

	private _mapApiOrderToTVOrder(apiOrder: any): Order | null {
		const ticket = apiOrder.ticket || apiOrder.Ticket || apiOrder.orderId || apiOrder.OrderId || apiOrder.id;
		const id = String(ticket);
		if (!id) return null;

		const symbol = apiOrder.symbol || apiOrder.Symbol;
		if (!symbol) return null;

		// Orders API returns numeric Type field:
		// 0 = Buy, 1 = Sell, 2 = Buy Limit, 3 = Sell Limit, 4 = Buy Stop, 5 = Sell Stop
		const orderType = apiOrder.Type ?? apiOrder.type ?? apiOrder.OrderType ?? apiOrder.orderType;

		let isBuy = false;
		let tvOrderType = OrderType.Limit;
		let typeText = '';

		if (typeof orderType === 'number') {
			switch (orderType) {
				case 0: // Buy Market
					isBuy = true;
					tvOrderType = OrderType.Market;
					typeText = 'Buy';
					break;
				case 1: // Sell Market
					isBuy = false;
					tvOrderType = OrderType.Market;
					typeText = 'Sell';
					break;
				case 2: // Buy Limit
					isBuy = true;
					tvOrderType = OrderType.Limit;
					typeText = 'Buy Limit';
					break;
				case 3: // Sell Limit
					isBuy = false;
					tvOrderType = OrderType.Limit;
					typeText = 'Sell Limit';
					break;
				case 4: // Buy Stop
					isBuy = true;
					tvOrderType = OrderType.Stop;
					typeText = 'Buy Stop';
					break;
				case 5: // Sell Stop
					isBuy = false;
					tvOrderType = OrderType.Stop;
					typeText = 'Sell Stop';
					break;
				default:
					// Fallback
					isBuy = true;
					tvOrderType = OrderType.Limit;
					typeText = 'Unknown';
			}
		} else {
			// Fallback to string parsing
			const typeStr = String(orderType || '').toLowerCase();
			isBuy = typeStr.includes('buy');
			if (typeStr.includes('limit')) {
				tvOrderType = OrderType.Limit;
			} else if (typeStr.includes('stop')) {
				tvOrderType = OrderType.Stop;
			}
			typeText = typeStr;
		}

		const side = isBuy ? Side.Buy : Side.Sell;

		// Map API status to TV status - pending orders are Working
		const status = OrderStatus.Working;

		// Orders API uses Volume field (in MT5 format: 1 = 0.01 lots, 100 = 1 lot)
		const rawVolume = apiOrder.Volume || apiOrder.volume || apiOrder.units || 0;
		const volumeLots = apiOrder.VolumeLots || apiOrder.volumeLots;

		let volume: number;
		if (volumeLots !== undefined && volumeLots !== null) {
			volume = Number(volumeLots);
		} else {
			// Convert MT5 volume to lots: divide by 100
			const numVolume = Math.abs(Number(rawVolume));
			volume = numVolume / 100;
		}

		// Orders API uses PriceOrder for the order price
		const openPrice = Number(
			apiOrder.PriceOrder || apiOrder.priceOrder ||
			apiOrder.OpenPrice || apiOrder.openPrice ||
			apiOrder.Price || apiOrder.price || 0
		);

		const mappedOrderType = tvOrderType;
		const mappedSide = side;

		return {
			id: id,
			symbol: symbol,
			qty: volume,
			side: side,
			sideText: isBuy ? 'Buy' : 'Sell',
			type: tvOrderType,
			status: status,
			limitPrice: tvOrderType === OrderType.Limit ? openPrice : undefined,
			stopPrice: tvOrderType === OrderType.Stop ? openPrice : undefined,
			takeProfit: Number(apiOrder.PriceTP || apiOrder.priceTP || apiOrder.TakeProfit || apiOrder.takeProfit || 0) || undefined,
			stopLoss: Number(apiOrder.PriceSL || apiOrder.priceSL || apiOrder.StopLoss || apiOrder.stopLoss || 0) || undefined,
			text: " ",
		} as unknown as Order;
	}

	private _createCleanPosition(p: Position): Position {
		// Clean position for TV display (similar to original)
		return {
			...p,
			takeProfit: p.takeProfit,
			stopLoss: p.stopLoss,
		};
	}

	private _createTakeProfitBracket(position: Position): Order {
		return {
			id: `${position.id}_TP`,
			symbol: position.symbol,
			qty: position.qty,
			side: changeSide(position.side),
			type: OrderType.Limit,
			status: OrderStatus.Working,
			limitPrice: position.takeProfit,
			parentId: position.id,
			parentType: ParentType.Position,
			text: "TP",
		} as unknown as Order;
	}

	private _createStopLossBracket(position: Position): Order {
		return {
			id: `${position.id}_SL`,
			symbol: position.symbol,
			qty: position.qty,
			side: changeSide(position.side),
			type: OrderType.Stop,
			status: OrderStatus.Working,
			stopPrice: position.stopLoss,
			parentId: position.id,
			parentType: ParentType.Position,
			text: "SL",
		} as unknown as Order;
	}

	private _isBracketOrder(order: Order): boolean {
		if (!order) return false;
		if (order.parentId || order.parentType !== undefined) return true;
		const id = (order.id || '').toString();
		return id.includes('_TP') || id.includes('_SL') || id.includes('TP-') || id.includes('SL-');
	}

	// Brackets for pending orders (use parentType=Order)
	private _createOrderTakeProfitBracket(order: Order): Order {
		const isPreview = order.id === PREVIEW_ORDER_ID;
		return {
			id: `${order.id}_TP`,
			symbol: order.symbol,
			qty: order.qty,
			side: changeSide(order.side),
			type: OrderType.Limit,
			status: OrderStatus.Working,
			limitPrice: order.takeProfit,
			parentId: order.id,
			parentType: ParentType.Order,
			text: "TP",
			sideText: isPreview ? " " : undefined,
			typeText: isPreview ? " " : undefined,
			qtyText: isPreview ? " " : undefined,
		} as unknown as Order;
	}

	private _createOrderStopLossBracket(order: Order): Order {
		const isPreview = order.id === PREVIEW_ORDER_ID;
		return {
			id: `${order.id}_SL`,
			symbol: order.symbol,
			qty: order.qty,
			side: changeSide(order.side),
			type: OrderType.Stop,
			status: OrderStatus.Working,
			stopPrice: order.stopLoss,
			parentId: order.id,
			parentType: ParentType.Order,
			text: "SL",
			sideText: isPreview ? " " : undefined,
			typeText: isPreview ? " " : undefined,
			qtyText: isPreview ? " " : undefined,
		} as unknown as Order;
	}



	public chartContextMenuActions(context: any, options?: DefaultContextMenuActionsParams): Promise<ActionMetaInfo[]> {
		return Promise.resolve([]);
	}

	public isTradable(symbol: string): Promise<IsTradableResult> {
		return Promise.resolve({ tradable: true });
	}

	public async placeOrder(preOrder: PreOrder): Promise<PlaceOrderResult> {
		console.log('[ZuperiorBroker] placeOrder called:', preOrder);
		if (!this._accessToken || !this._accountId) {
			return Promise.reject('Not authenticated');
		}

		// Pause polling
		this._lastActionTime = Date.now();

		const side = preOrder.side === 1 ? 'buy' : 'sell';
		const volume = preOrder.qty; // already in lots? Standard TV sends what we configured (qty)

		try {
			if (preOrder.type === OrderType.Market) { // Market
				await placeMarketOrderDirect({
					accountId: this._accountId,
					accessToken: this._accessToken,
					symbol: preOrder.symbol,
					side: side,
					volume: volume,
					stopLoss: preOrder.stopLoss,
					takeProfit: preOrder.takeProfit
				});
			} else {
				// Pending
				const price = (preOrder as any).limitPrice || (preOrder as any).stopPrice || 0;
				const orderType = preOrder.type === OrderType.Limit ? 'limit' : 'stop'; // simplified

				await placePendingOrderDirect({
					accountId: this._accountId,
					accessToken: this._accessToken,
					symbol: preOrder.symbol,
					side: side,
					volume: volume,
					price: price,
					orderType: orderType,
					stopLoss: preOrder.stopLoss,
					takeProfit: preOrder.takeProfit
				});
			}
			// Refresh soon (force redraw quickly once backend confirms)
			setTimeout(() => this._fetchPositionsAndOrders(true), 600);
			return {};
		} catch (e: any) {
			console.error('Place order failed', e);
			throw e;
		}
	}


	// TradingView calls this when a pending/order line is dragged
	public async modifyOrder(order: Order, confirmId?: string): Promise<void> {
		console.log('[ZuperiorBroker] modifyOrder called:', order.id, order);

		if (!this._accessToken || !this._accountId) {
			return Promise.reject('Not authenticated');
		}

		this._lastActionTime = Date.now();

		const originalOrder = this._orderById[order.id];
		if (!originalOrder) {
			console.error('[ZuperiorBroker] modifyOrder failed: Order not found', order.id);
			return Promise.reject('Order not found');
		}

		// Handle bracket order modification (dragging TP/SL lines)
		if (order.parentId !== undefined) {
			const isTP = order.id.toString().includes('_TP');
			const isSL = order.id.toString().includes('_SL');

			const mod: any = {};
			if (isTP && order.limitPrice !== undefined) mod.takeProfit = order.limitPrice;
			if (isSL && order.stopPrice !== undefined) mod.stopLoss = order.stopPrice;

			console.log('[ZuperiorBroker] modifyOrder: Bracket drag detected');
			console.log('[ZuperiorBroker] modifyOrder: Parent ID:', order.parentId);
			console.log('[ZuperiorBroker] modifyOrder: Parent Type:', order.parentType);
			console.log('[ZuperiorBroker] modifyOrder: Modification:', mod);
			console.log('[ZuperiorBroker] modifyOrder: Is Preview?', order.parentId === 'PREVIEW_ORDER_ID');

			if (order.parentType === ParentType.Position) {
				return this.editPositionBrackets(order.parentId, mod);
			} else {
				// This will call editOrder which emits __ON_ORDER_PREVIEW_CHANGE__ for preview orders
				console.log('[ZuperiorBroker] modifyOrder: Calling editOrder for bracket modification');
				return this.editOrder(order.parentId, mod);
			}
		}

		// Handle pending order modification (dragging order line)
		originalOrder.limitPrice = order.limitPrice !== undefined ? order.limitPrice : originalOrder.limitPrice;
		originalOrder.stopPrice = order.stopPrice !== undefined ? order.stopPrice : originalOrder.stopPrice;
		originalOrder.takeProfit = order.takeProfit !== undefined ? order.takeProfit : originalOrder.takeProfit;
		originalOrder.stopLoss = order.stopLoss !== undefined ? order.stopLoss : originalOrder.stopLoss;
		originalOrder.qty = order.qty !== undefined ? order.qty : originalOrder.qty;

		this._orderById[order.id] = originalOrder;

		const newTP = originalOrder.takeProfit;
		const newSL = originalOrder.stopLoss;

		// Regenerate brackets
		delete this._orderById[`${order.id}_TP`];
		delete this._orderById[`${order.id}_SL`];
		this._orders = this._orders.filter(o => !(o.id === `${order.id}_TP` || o.id === `${order.id}_SL`));

		if (newTP && newTP > 0) {
			const tpB = this._createOrderTakeProfitBracket(originalOrder);
			this._orderById[tpB.id] = tpB;
			this._orders.push(tpB);
		}
		if (newSL && newSL > 0) {
			const slB = this._createOrderStopLossBracket(originalOrder);
			this._orderById[slB.id] = slB;
			this._orders.push(slB);
		}

		this._notifyAllPositionsAndOrders();

		// Persist to API
		try {
			// SKIP API FOR PREVIEW
			if (order.id === PREVIEW_ORDER_ID) {
				console.log('[ZuperiorBroker] modifyOrder: Skipping API for preview order');
				// Emit event for OrderPanel sync
				if (typeof window !== 'undefined') {
					(window as any).dispatchEvent(new CustomEvent('__ON_ORDER_PREVIEW_CHANGE__', {
						detail: {
							id: order.id,
							price: originalOrder.type === OrderType.Limit ? originalOrder.limitPrice : originalOrder.stopPrice,
							takeProfit: newTP,
							stopLoss: newSL,
							qty: originalOrder.qty
						}
					}));
				}
				return Promise.resolve();
			}

			await modifyPendingOrderDirect({
				accountId: this._accountId,
				accessToken: this._accessToken,
				orderId: order.id,
				price: originalOrder.type === OrderType.Limit ? originalOrder.limitPrice : originalOrder.stopPrice,
				stopLoss: newSL,
				takeProfit: newTP
			});
			setTimeout(() => this._fetchPositionsAndOrders(true), 400);
		} catch (e) {
			console.error('[ZuperiorBroker] modifyOrder API call failed:', e);
			this._fetchPositionsAndOrders();
			throw e;
		}
	}


	public async cancelOrder(orderId: string): Promise<void> {
		if (!this._accessToken || !this._accountId) return Promise.reject("Auth failed");

		console.log('[ZuperiorBroker] cancelOrder called for:', orderId);

		// CHECK IF THIS IS A BRACKET CANCELLATION
		const isTP = orderId.endsWith('_TP');
		const isSL = orderId.endsWith('_SL');

		if (isTP || isSL) {
			const parentId = orderId.replace('_TP', '').replace('_SL', '');
			console.log('[ZuperiorBroker] Bracket cancellation detected. Modifying parent:', parentId);

			// Check if parent is a position
			if (this._positionById[parentId]) {
				const modification = isTP ? { takeProfit: 0 } : { stopLoss: 0 };
				return this.editPositionBrackets(parentId, modification);
			}

			// Check if parent is an order
			if (this._orderById[parentId]) {
				const modification = isTP ? { takeProfit: 0 } : { stopLoss: 0 };
				return this.editOrder(parentId, modification);
			}

			console.warn('[ZuperiorBroker] Parent entity not found for bracket cancel:', parentId);
			return Promise.resolve(); // Fallback
		}

		// Optimistic update for regular orders
		const order = this._orderById[orderId];
		if (order) {
			// Remove from maps
			delete this._orderById[orderId];
			// Remove from array
			this._orders = this._orders.filter(o => o.id !== orderId);
			// Notify chart
			this._notifyAllPositionsAndOrders();
		}

		if (orderId === PREVIEW_ORDER_ID) {
			return Promise.resolve();
		}

		try {
			await cancelPendingOrderDirect({
				accountId: this._accountId,
				accessToken: this._accessToken,
				orderId: orderId
			});
			setTimeout(() => this._fetchPositionsAndOrders(true), 400);
		} catch (e) {
			console.error('Cancel order failed', e);
			// Rollback if failed (fetch will restore it)
			this._fetchPositionsAndOrders();
			throw e;
		}
	}

	private _notifyBracketCancelled(bracketId: string, bracketObj?: Order) {
		const bracket = bracketObj || this._orderById[bracketId];
		if (this._host && typeof this._host.orderUpdate === 'function') {
			this._host.orderUpdate({ ...(bracket || { id: bracketId }), status: OrderStatus.Canceled });
		}
	}

	public async editPositionBrackets(positionId: string, modification: any): Promise<void> {
		if (!this._accessToken || !this._accountId) return Promise.reject("Auth failed");

		// Pause polling to protect optimistic update
		this._lastActionTime = Date.now();

		// 1. Capture current state for rollback
		const originalPosition = this._positionById[positionId];
		if (!originalPosition) {
			console.error('[ZuperiorBroker] Position not found for edit:', positionId);
			return;
		}
		// Clone for safety
		const originalState = { ...originalPosition };

		// Normalize TP/SL values (TradingView may send null/undefined to clear)
		// Preserve existing brackets when the other one is modified.
		const newTPRaw = modification.takeProfit ?? modification.tp;
		const newSLRaw = modification.stopLoss ?? modification.sl;

		const newTP =
			newTPRaw === null
				? 0
				: newTPRaw === undefined || isNaN(Number(newTPRaw))
					? originalPosition.takeProfit ?? 0
					: Number(newTPRaw);

		const newSL =
			newSLRaw === null
				? 0
				: newSLRaw === undefined || isNaN(Number(newSLRaw))
					? originalPosition.stopLoss ?? 0
					: Number(newSLRaw);

		// 2. Optimistic Update
		console.log('[ZuperiorBroker] Optimistic Update for Position:', positionId, modification);

		if (newSL !== undefined) originalPosition.stopLoss = newSL;
		if (newTP !== undefined) originalPosition.takeProfit = newTP;

		// Update _positions array reference
		const index = this._positions.findIndex(p => p.id === positionId);
		if (index !== -1) {
			this._positions[index] = { ...originalPosition };
			// Ensure map points to new object reference
			this._positionById[positionId] = this._positions[index];
		}

		// CRITICAL: Update existing brackets in-place if possible, or create new ones
		const tpId = `${positionId}_TP`;
		const slId = `${positionId}_SL`;
		const existingTP = this._orderById[tpId];
		const existingSL = this._orderById[slId];

		// Regenerate brackets with new values
		const newPos = this._positionById[positionId];

		// --- Handle TP Bracket ---
		if (newPos.takeProfit && newPos.takeProfit > 0) {
			if (existingTP) {
				// Update existing TP bracket (Immutable update)
				const updatedTP = {
					...existingTP,
					limitPrice: newPos.takeProfit,
					qty: newPos.qty, // Update qty in case position size changed
					status: OrderStatus.Working
				};
				this._orderById[tpId] = updatedTP;
				// Update array reference
				const tpIndex = this._orders.findIndex(o => o.id === tpId);
				if (tpIndex !== -1) {
					this._orders[tpIndex] = updatedTP;
				} else {
					// Should be in array if in map, but safe fallback
					this._orders.push(updatedTP);
				}
				console.log('[ZuperiorBroker] Updated existing Position TP Bracket:', updatedTP.id, updatedTP.limitPrice);
			} else {
				// Create new TP bracket
				try {
					const tpBracket = this._createTakeProfitBracket(newPos);
					this._orderById[tpBracket.id] = tpBracket;
					this._orders.push(tpBracket);
					console.log('[ZuperiorBroker] Created new Position TP Bracket:', tpBracket);
				} catch (e) {
					console.error('[ZuperiorBroker] Error creating TP bracket', e);
				}
			}
		} else {
			// TP removed
			if (existingTP) {
				this._notifyBracketCancelled(tpId, existingTP);
				delete this._orderById[tpId];
				this._orders = this._orders.filter(o => o.id !== tpId);
			}
		}

		// --- Handle SL Bracket ---
		if (newPos.stopLoss && newPos.stopLoss > 0) {
			if (existingSL) {
				// Update existing SL bracket (Immutable update)
				const updatedSL = {
					...existingSL,
					stopPrice: newPos.stopLoss,
					qty: newPos.qty,
					status: OrderStatus.Working
				};
				this._orderById[slId] = updatedSL;
				// Update array reference
				const slIndex = this._orders.findIndex(o => o.id === slId);
				if (slIndex !== -1) {
					this._orders[slIndex] = updatedSL;
				} else {
					this._orders.push(updatedSL);
				}
				console.log('[ZuperiorBroker] Updated existing Position SL Bracket:', updatedSL.id, updatedSL.stopPrice);
			} else {
				// Create new SL bracket
				try {
					const slBracket = this._createStopLossBracket(newPos);
					this._orderById[slBracket.id] = slBracket;
					this._orders.push(slBracket);
					console.log('[ZuperiorBroker] Created new Position SL Bracket:', slBracket);
				} catch (e) {
					console.error('[ZuperiorBroker] Error creating SL bracket', e);
				}
			}
		} else {
			// SL removed
			if (existingSL) {
				this._notifyBracketCancelled(slId, existingSL);
				delete this._orderById[slId];
				this._orders = this._orders.filter(o => o.id !== slId);
			}
		}

		// 3. Notify Chart IMMEDIATELY
		this._notifyAllPositionsAndOrders();

		try {
			// 4. API Call in Background
			await modifyPositionDirect({
				accountId: this._accountId,
				accessToken: this._accessToken,
				positionId: positionId,
				stopLoss: newSL,
				takeProfit: newTP
			});

			// Fetch validation after a short delay to confirm backend state
			setTimeout(() => this._fetchPositionsAndOrders(true), 400);

		} catch (e) {
			console.error('Modify position failed', e);

			// 5. Rollback on Failure
			console.log('[ZuperiorBroker] Rolling back optimistic update');
			const posToRevert = this._positionById[positionId];
			if (posToRevert) {
				posToRevert.takeProfit = originalState.takeProfit;
				posToRevert.stopLoss = originalState.stopLoss;

				// Regenerate old brackets? Or just let fetch fix it?
				// Re-notifying will at least correct the position lines
				this._notifyAllPositionsAndOrders();
			}
			// Force re-fetch to ensure sync
			this._fetchPositionsAndOrders(true);

			throw e;
		}
	}

	public async closePosition(positionId: string): Promise<void> {
		if (!this._accessToken || !this._accountId) return Promise.reject("Auth failed");

		console.log('[ZuperiorBroker] closePosition called for:', positionId);

		// Optimistic update: Remove from local state immediately
		const position = this._positionById[positionId];
		if (position) {
			// Notify chart/AM of closure BEFORE removing from state
			if (this._host && typeof this._host.positionUpdate === 'function') {
				const closedPosition = { ...position, qty: 0, avgPrice: 0 };
				console.log('[ZuperiorBroker] Optimistic Close - Notifying host:', closedPosition);
				this._host.positionUpdate(closedPosition);

				if ((position as any).pl !== undefined && typeof this._host.plUpdate === 'function') {
					// Update P/L to 0 or remove it? Usually just updating position is enough.
				}
			}

			// Remove from maps
			delete this._positionById[positionId];
			delete this._orderById[`${positionId}_TP`];
			delete this._orderById[`${positionId}_SL`];

			// Remove from array
			this._positions = this._positions.filter(p => p.id !== positionId);

			// Notify chart (updates the rest)
			this._notifyAllPositionsAndOrders();
		}

		try {
			await closePositionDirect({
				accountId: this._accountId,
				accessToken: this._accessToken,
				positionId: positionId,
				volume: position ? position.qty : 0 // Pass known volume (lots) to help API
			});
			// Fetch validation after delay
			setTimeout(() => this._fetchPositionsAndOrders(true), 500);
		} catch (e) {
			console.error('Close position failed', e);
			// Re-fetch to restore if failed
			this._fetchPositionsAndOrders(true);
			throw e;
		}
	}

	public accountManagerInfo(): AccountManagerInfo {
		const orderColumns: any[] = [
			{
				id: 'symbol',
				label: 'Symbol',
				dataFields: ['symbol'],
				formatter: StandardFormatterName.Text,
			},
			{
				id: 'side',
				label: 'Side',
				dataFields: ['sideText'],
				formatter: StandardFormatterName.Text,
			},
			{
				id: 'qty',
				label: 'Qty',
				dataFields: ['qty'],
				formatter: StandardFormatterName.Fixed,
			},
			{
				id: 'status',
				label: 'Status',
				dataFields: ['status'],
				formatter: StandardFormatterName.Text,
			}
		];

		const positionColumns: any[] = [
			{
				id: 'symbol',
				label: 'Symbol',
				dataFields: ['symbol'],
				formatter: StandardFormatterName.Text,
			},
			{
				id: 'side',
				label: 'Side',
				dataFields: ['sideText'],
				formatter: StandardFormatterName.Text,
			},
			{
				id: 'qty',
				label: 'Qty',
				dataFields: ['qty'],
				formatter: StandardFormatterName.Fixed,
			},
			{
				id: 'avgPrice',
				label: 'Price',
				dataFields: ['avgPrice'],
				formatter: StandardFormatterName.FormatPrice,
			},
			{
				id: 'profit',
				label: 'Profit',
				dataFields: ['profit'],
				formatter: StandardFormatterName.Fixed,
			}
		];

		return {
			accountTitle: 'Zuperior Financial',
			summary: [
				{
					text: 'Balance',
					wValue: {
						subscribe: (onChange: any) => { },
						unsubscribe: (onChange: any) => { },
						value: () => this._accountBalance,
						when: (callback: any) => { } // Dummy implementation to satisfy interface
					},
					formatter: StandardFormatterName.Fixed // Using fixed format
				}
			],
			orderColumns: orderColumns,
			positionColumns: positionColumns,
			pages: [
				{
					id: 'positions',
					title: 'Positions',
					tables: [
						{
							id: 'positions',
							columns: positionColumns,
							getData: () => Promise.resolve(this._positions),
							changeDelegate: this._positionsSubscription
						}
					]
				},
				{
					id: 'orders',
					title: 'Orders',
					tables: [
						{
							id: 'orders',
							columns: orderColumns,
							getData: () => Promise.resolve(this._orders),
							changeDelegate: this._ordersSubscription
						}
					]
				}
			]
		};
	}

	public accountsMetainfo(): Promise<AccountMetainfo[]> {
		return Promise.resolve([
			{
				id: (this._accountId || '1') as AccountId,
				name: 'Zuperior Main',
				currency: 'USD'
			}
		]);
	}
	public async orders(): Promise<Order[]> {
		return Promise.resolve(this._orders);
	}

	public async positions(): Promise<Position[]> {
		return Promise.resolve(this._positions);
	}

	public async executions(symbol: string): Promise<Execution[]> {
		return [];
	}

	public currentAccount(): AccountId {
		return (this._accountId || '') as AccountId;
	}

	public async symbolInfo(symbol: string): Promise<InstrumentInfo> {
		const symbolUpper = symbol.toUpperCase();
		let pricescale = 100000; // Default Forex
		let minTick = 0.00001;

		if (symbolUpper.includes('JPY') || symbolUpper.includes('XAU')) {
			pricescale = 100;
			minTick = 0.01;
		} else if (symbolUpper.includes('BTC') || symbolUpper.includes('ETH') || symbolUpper.includes('SOL')) {
			pricescale = 100;
			minTick = 0.01;
		}

		return {
			qty: { min: 0.01, max: 100, step: 0.01 },
			pipSize: minTick,
			pipValue: 1,
			minTick: minTick,
			description: symbol,
			type: 'crypto',
			domVolumePrecision: 2,
			id: symbol,
			name: symbol,
			minMove2: 0,
			pricescale: pricescale,
			minmov: 1,
			fractional: false,
			session: '24x7',
			timezone: 'Etc/UTC',
			has_intraday: true,
			has_no_volume: false,
			data_status: 'streaming'
		} as unknown as InstrumentInfo;
	}

	public formatter(symbol: string, alignToMinMove?: boolean): Promise<any> {
		return Promise.resolve({
			format: (value: number) => {
				if (value === undefined || value === null) return '';
				return value.toFixed(2);
			}
		});
	}

	public spreadFormatter(symbol: string): Promise<any> {
		return Promise.resolve({
			format: (value: number) => {
				if (value === undefined || value === null) return '';
				return value.toFixed(1) + ' pips';
			}
		});
	}

	public quantityFormatter(symbol: string): Promise<any> {
		return Promise.resolve({
			format: (value: number) => {
				if (value === undefined || value === null) return '';
				return value.toString();
			}
		});
	}

	public pipValueFormatter(symbol: string): Promise<any> {
		return Promise.resolve({
			format: (value: number) => {
				if (value === undefined || value === null) return '';
				return value.toFixed(2);
			}
		});
	}
	public async editOrder(orderId: string, modification: any): Promise<void> {
		const originalOrder = this._orderById[orderId];
		if (!originalOrder) {
			console.error(`[ZuperiorBroker] Order not found: ${orderId}`);
			return Promise.reject('Order not found');
		}

		console.log('[ZuperiorBroker] editOrder called:', orderId, modification);

		// SKIP API FOR PREVIEW
		if (orderId === PREVIEW_ORDER_ID) {
			console.log('[ZuperiorBroker] editOrder: Skipping API for preview order');

			// Update local state
			const entryPrice = (originalOrder.type === OrderType.Limit ? originalOrder.limitPrice : originalOrder.stopPrice) || 0;
			const side = originalOrder.side; // Buy=1, Sell=-1

			if (modification.limitPrice !== undefined) originalOrder.limitPrice = modification.limitPrice;
			if (modification.stopPrice !== undefined) originalOrder.stopPrice = modification.stopPrice;
			if (modification.qty !== undefined) originalOrder.qty = modification.qty;

			// Directional validation for TP/SL
			if (modification.takeProfit !== undefined && entryPrice > 0) {
				const tp = modification.takeProfit;
				const isValid = side === Side.Buy ? tp > entryPrice : tp < entryPrice;
				if (isValid) originalOrder.takeProfit = tp;
			}
			if (modification.stopLoss !== undefined && entryPrice > 0) {
				const sl = modification.stopLoss;
				const isValid = side === Side.Buy ? sl < entryPrice : sl > entryPrice;
				if (isValid) originalOrder.stopLoss = sl;
			}

			this._orderById[orderId] = originalOrder;

			// Regents brackets (Preserve objects to allow continuous dragging)
			const tpId = `${orderId}_TP`;
			const slId = `${orderId}_SL`;

			if (originalOrder.takeProfit && originalOrder.takeProfit > 0) {
				const existingTP = this._orderById[tpId];
				if (existingTP) {
					(existingTP as any).limitPrice = originalOrder.takeProfit;
					this._host.orderUpdate(existingTP);
				} else {
					const tpB = this._createOrderTakeProfitBracket(originalOrder);
					this._orderById[tpB.id] = tpB;
					this._orders.push(tpB);
					this._host.orderUpdate(tpB);
				}
			} else {
				if (this._orderById[tpId]) {
					const cancelledTP = { ...this._orderById[tpId], status: OrderStatus.Canceled };
					this._host.orderUpdate(cancelledTP);
					delete this._orderById[tpId];
					this._orders = this._orders.filter(o => o.id !== tpId);
				}
			}

			if (originalOrder.stopLoss && originalOrder.stopLoss > 0) {
				const existingSL = this._orderById[slId];
				if (existingSL) {
					(existingSL as any).stopPrice = originalOrder.stopLoss;
					this._host.orderUpdate(existingSL);
				} else {
					const slB = this._createOrderStopLossBracket(originalOrder);
					this._orderById[slB.id] = slB;
					this._orders.push(slB);
					this._host.orderUpdate(slB);
				}
			} else {
				if (this._orderById[slId]) {
					const cancelledSL = { ...this._orderById[slId], status: OrderStatus.Canceled };
					this._host.orderUpdate(cancelledSL);
					delete this._orderById[slId];
					this._orders = this._orders.filter(o => o.id !== slId);
				}
			}

			this._notifyAllPositionsAndOrders();

			// Emit event for OrderPanel sync
			if (typeof window !== 'undefined') {
				(window as any).dispatchEvent(new CustomEvent('__ON_ORDER_PREVIEW_CHANGE__', {
					detail: {
						id: orderId,
						price: originalOrder.type === OrderType.Limit ? originalOrder.limitPrice : originalOrder.stopPrice,
						takeProfit: originalOrder.takeProfit,
						stopLoss: originalOrder.stopLoss,
						qty: originalOrder.qty,
						source: 'chart'
					}
				}));
			}
			return Promise.resolve();
		}

		this._lastActionTime = Date.now();

		const originalState = { ...originalOrder };
		const tpId = `${orderId}_TP`;
		const slId = `${orderId}_SL`;

		// capture prior bracket state
		const existingTP = this._orderById[tpId];
		const existingSL = this._orderById[slId];

		// Update local order object with new values
		if (modification.limitPrice !== undefined) originalOrder.limitPrice = modification.limitPrice;
		if (modification.stopPrice !== undefined) originalOrder.stopPrice = modification.stopPrice;
		if (modification.takeProfit !== undefined) originalOrder.takeProfit = modification.takeProfit;
		if (modification.stopLoss !== undefined) originalOrder.stopLoss = modification.stopLoss;

		// --- Handle TP Bracket ---
		if (originalOrder.takeProfit && originalOrder.takeProfit > 0) {
			if (existingTP) {
				// Update existing (Immutable update for React/TV change detection)
				const updatedTP = {
					...existingTP,
					limitPrice: originalOrder.takeProfit,
					qty: originalOrder.qty,
					status: OrderStatus.Working // Force status
				};
				this._orderById[tpId] = updatedTP;
				// Update array reference
				const tpIndex = this._orders.findIndex(o => o.id === tpId);
				if (tpIndex !== -1) {
					this._orders[tpIndex] = updatedTP;
				}
				console.log('[ZuperiorBroker] Updated existing TP bracket (immutable):', updatedTP.id, updatedTP.limitPrice);
			} else {
				// Create new
				const tpBracket = this._createOrderTakeProfitBracket(originalOrder);
				this._orderById[tpBracket.id] = tpBracket;
				this._orders.push(tpBracket);
			}
		} else {
			// TP removed or was never there
			if (existingTP) {
				// Notify cancellation BEFORE deleting
				this._notifyBracketCancelled(tpId, existingTP);
				// Remove from maps and array
				delete this._orderById[tpId];
				this._orders = this._orders.filter(o => o.id !== tpId);
			}
		}

		// --- Handle SL Bracket ---
		if (originalOrder.stopLoss && originalOrder.stopLoss > 0) {
			if (existingSL) {
				// Update existing (Immutable update)
				const updatedSL = {
					...existingSL,
					stopPrice: originalOrder.stopLoss,
					qty: originalOrder.qty,
					status: OrderStatus.Working // Force status
				};
				this._orderById[slId] = updatedSL;
				// Update array reference
				const slIndex = this._orders.findIndex(o => o.id === slId);
				if (slIndex !== -1) {
					this._orders[slIndex] = updatedSL;
				}
				console.log('[ZuperiorBroker] Updated existing SL bracket (immutable):', updatedSL.id, updatedSL.stopPrice);
			} else {
				// Create new
				const slBracket = this._createOrderStopLossBracket(originalOrder);
				this._orderById[slBracket.id] = slBracket;
				this._orders.push(slBracket);
			}
		} else {
			// SL removed
			if (existingSL) {
				// Notify cancellation BEFORE deleting
				this._notifyBracketCancelled(slId, existingSL);
				// Remove from maps and array
				delete this._orderById[slId];
				this._orders = this._orders.filter(o => o.id !== slId);
			}
		}

		// Update array reference for the parent order (trigger React/TV updates)
		const index = this._orders.findIndex(o => o.id === orderId);
		if (index !== -1) {
			// We mutated originalOrder in place, which is inside _orders[index] if it was by reference.
			// But to be safe and trigger change detection, we shallow copy it back.
			this._orders[index] = { ...originalOrder };
			this._orderById[orderId] = this._orders[index];
		}

		// Notify all updates
		this._notifyAllPositionsAndOrders();

		try {
			// Use values from originalOrder which now contains the merged state
			await modifyPendingOrderDirect({
				accountId: this._accountId!,
				accessToken: this._accessToken!,
				orderId: orderId,
				price: originalOrder.limitPrice || originalOrder.stopPrice,
				stopLoss: originalOrder.stopLoss,
				takeProfit: originalOrder.takeProfit
			});
			// Re-fetch to validate
			setTimeout(() => this._fetchPositionsAndOrders(true), 400);
		} catch (e) {
			console.error('[ZuperiorBroker] Modify order failed', e);
			// Rollback (Simplified: just re-fetch to restore state)
			this._fetchPositionsAndOrders(true);
			throw e;
		}
	}

	public async modifyEntity(id: string, modification: any): Promise<void> {
		// Check if it's a position
		if (this._positionById[id]) {
			return this.editPositionBrackets(id, modification);
		}
		// Check if it's an order
		if (this._orderById[id]) {
			// Adapter for order modification fields
			const orderMod: any = {};
			if (modification.tp !== undefined) orderMod.takeProfit = modification.tp;
			if (modification.sl !== undefined) orderMod.stopLoss = modification.sl;

			// Map price if provided (from "Price" field in modal for Pending Orders)
			if (modification.price !== undefined) {
				const order = this._orderById[id];
				if (order.type === OrderType.Limit) {
					orderMod.limitPrice = modification.price;
				} else if (order.type === OrderType.Stop) {
					orderMod.stopPrice = modification.price;
				}
			}

			// Pass other fields if present custom ones
			if (modification.limitPrice) orderMod.limitPrice = modification.limitPrice;
			if (modification.stopPrice) orderMod.stopPrice = modification.stopPrice;
			if (modification.takeProfit) orderMod.takeProfit = modification.takeProfit;
			if (modification.stopLoss) orderMod.stopLoss = modification.stopLoss;

			// Update parent order properties to match bracket changes
			// Update parent order properties to match bracket changes
			const entity = this._orderById[id];
			// If this entity is a bracket (has parentId), update the parent.
			// If it's the main order, it's already being updated via editOrder logic, but detailed props need syncing.
			if (entity && entity.parentId) {
				const actualParent = this._orderById[entity.parentId];
				if (actualParent) {
					if (modification.limitPrice !== undefined) actualParent.takeProfit = modification.limitPrice;
					if (modification.stopPrice !== undefined) actualParent.stopLoss = modification.stopPrice;
					if (modification.takeProfit !== undefined) actualParent.takeProfit = modification.takeProfit;
					if (modification.stopLoss !== undefined) actualParent.stopLoss = modification.stopLoss;

					// Notify parent update immediately
					if (this._host && typeof this._host.orderUpdate === 'function') {

						this._host.orderUpdate(actualParent);
					}
				}
			} else if (entity) {
				// It is the parent order itself.
				// We still want to ensure prop consistency if we are setting new params
				if (modification.limitPrice !== undefined) entity.takeProfit = modification.limitPrice;
				if (modification.stopPrice !== undefined) entity.stopLoss = modification.stopPrice;
				if (modification.takeProfit !== undefined) entity.takeProfit = modification.takeProfit;
				if (modification.stopLoss !== undefined) entity.stopLoss = modification.stopLoss;
				// Notification happens in editOrder flow usually, but safe to do here if needed. 
				// editOrder will usually handle the main notification.
			}

			return this.editOrder(id, orderMod);
		}

		console.error('[ZuperiorBroker] Entity not found for modification:', id);
		return Promise.reject('Entity not found');
	}

	// TradingView calls this when a pending/order line is dragged
	public async moveOrder(orderId: string, price: number): Promise<void> {
		console.log('[ZuperiorBroker] moveOrder invoked:', orderId, price);
		const order = this._orderById[orderId];
		if (!order) {
			console.error('[ZuperiorBroker] moveOrder failed: Order not found', orderId);
			return Promise.reject('Order not found');
		}
		const isTP = orderId.includes('_TP') || orderId.includes('TP-');
		const isSL = orderId.includes('_SL') || orderId.includes('SL-');

		console.log('[ZuperiorBroker] Moving order details:', { isTP, isSL, parentId: order.parentId, parentType: order.parentType });

		// If this is a bracket of a pending order
		if (order.parentId && order.parentType === ParentType.Order && (isTP || isSL)) {
			const mod: any = {};
			if (isTP) mod.takeProfit = price;
			if (isSL) mod.stopLoss = price;
			console.log('[ZuperiorBroker] Moving pending order bracket -> editOrder', order.parentId, mod);
			return this.editOrder(order.parentId, mod);
		}

		// If this is a bracket of a position
		if (order.parentId && order.parentType === ParentType.Position && (isTP || isSL)) {
			const mod: any = {};
			if (isTP) mod.takeProfit = price;
			if (isSL) mod.stopLoss = price;
			console.log('[ZuperiorBroker] Moving position bracket -> editPositionBrackets', order.parentId, mod);
			return this.editPositionBrackets(order.parentId, mod);
		}

		// Base pending order line drag
		const mod: any = {};
		if (order.type === OrderType.Stop) {
			mod.stopPrice = price;
		} else {
			mod.limitPrice = price;
		}
		console.log('[ZuperiorBroker] Moving pending order main line -> editOrder', orderId, mod);
		return this.editOrder(orderId, mod);
	}

	// TradingView calls this when TP/SL of a position is dragged
	public async movePositionBrackets(positionId: string, brackets: any): Promise<void> {
		console.log('[ZuperiorBroker] movePositionBrackets invoked:', positionId, brackets);
		return this.editPositionBrackets(positionId, brackets);
	}

	// Fallback alias used by some builds
	public async movePosition(positionId: string, brackets: any): Promise<void> {
		console.log('[ZuperiorBroker] movePosition invoked:', positionId, brackets); // Often same as movePositionBrackets regarding arg signature? No, movePosition might imply modifying execution price which isn't possible, but TV uses it for brackets sometimes.
		// Actually movePosition signature in API is (id, price) usually?
		// But here we mapped it to brackets in previous logic. Let's check signature.
		// If brackets is a price number, it would die.
		// Usually movePosition is for moving the *entry* price (not possible for market positions)
		// But in this library version, it might map to brackets.
		return this.editPositionBrackets(positionId, brackets);
	}

	public setOrderPreview(previewData: {
		symbol?: string,
		side?: 'buy' | 'sell' | null,
		qty?: number,
		price?: number,
		type?: 'market' | 'limit' | 'stop',
		takeProfit?: number,
		stopLoss?: number
	}): void {
		if (!this._host || typeof this._host.orderUpdate !== 'function') return;

		if (!previewData.side) {
			// Cancel preview
			const existing = this._orderById[PREVIEW_ORDER_ID];
			if (existing) {
				const canceledPreview = {
					...existing,
					status: OrderStatus.Canceled,
				};
				console.log('[ZuperiorBroker] Canceling order preview');
				this._host.orderUpdate(canceledPreview);
				delete this._orderById[PREVIEW_ORDER_ID];

				// Also remove brackets
				delete this._orderById[`${PREVIEW_ORDER_ID}_TP`];
				delete this._orderById[`${PREVIEW_ORDER_ID}_SL`];

				// Also remove from _orders array to keep internal state consistent
				this._orders = this._orders.filter(o => !o.id.toString().startsWith(PREVIEW_ORDER_ID));
			}
			return;
		}

		// Create or update preview order
		const side = previewData.side === 'buy' ? Side.Buy : Side.Sell;
		const qty = previewData.qty || 1;
		const price = previewData.price || 0;
		const symbol = previewData.symbol || 'XAUUSD';

		const previewOrder: Order = {
			id: PREVIEW_ORDER_ID,
			symbol: symbol,
			side: side,
			qty: qty,
			status: OrderStatus.Working,
			type: previewData.type === 'stop' ? OrderType.Stop : (previewData.type === 'limit' ? OrderType.Limit : OrderType.Limit),
			limitPrice: price,
			stopPrice: previewData.type === 'stop' ? price : undefined,
			takeProfit: previewData.takeProfit,
			stopLoss: previewData.stopLoss,
			text: " ",
			sideText: " ", // Hide side text
			typeText: " ", // Hide type text
			qtyText: " ",  // Hide qty text
		};

		console.log('[ZuperiorBroker] Setting order preview:', previewOrder);
		this._orderById[PREVIEW_ORDER_ID] = previewOrder;

		// Update _orders array as well so orders() returns it
		const existingIndex = this._orders.findIndex(o => o.id === PREVIEW_ORDER_ID);
		if (existingIndex >= 0) {
			this._orders[existingIndex] = previewOrder;
		} else {
			this._orders.push(previewOrder);
		}

		// Handle preview brackets (Preserve objects to allow iteration)
		const tpId = `${PREVIEW_ORDER_ID}_TP`;
		const slId = `${PREVIEW_ORDER_ID}_SL`;

		if (previewOrder.takeProfit && previewOrder.takeProfit > 0) {
			const existingTP = this._orderById[tpId];
			if (existingTP) {
				(existingTP as any).limitPrice = previewOrder.takeProfit;
				this._host.orderUpdate(existingTP);
			} else {
				const tpB = this._createOrderTakeProfitBracket(previewOrder);
				this._orderById[tpB.id] = tpB;
				this._orders.push(tpB);
				this._host.orderUpdate(tpB);
			}
		} else {
			if (this._orderById[tpId]) {
				const cancelledTP = { ...this._orderById[tpId], status: OrderStatus.Canceled };
				this._host.orderUpdate(cancelledTP);
				delete this._orderById[tpId];
				this._orders = this._orders.filter(o => o.id !== tpId);
			}
		}

		if (previewOrder.stopLoss && previewOrder.stopLoss > 0) {
			const existingSL = this._orderById[slId];
			if (existingSL) {
				(existingSL as any).stopPrice = previewOrder.stopLoss;
				this._host.orderUpdate(existingSL);
			} else {
				const slB = this._createOrderStopLossBracket(previewOrder);
				this._orderById[slB.id] = slB;
				this._orders.push(slB);
				this._host.orderUpdate(slB);
			}
		} else {
			if (this._orderById[slId]) {
				const cancelledSL = { ...this._orderById[slId], status: OrderStatus.Canceled };
				this._host.orderUpdate(cancelledSL);
				delete this._orderById[slId];
				this._orders = this._orders.filter(o => o.id !== slId);
			}
		}

		this._host.orderUpdate(previewOrder);
		this._notifyAllPositionsAndOrders();

		// Sync back to panel if needed (optional confirmation)
		if (typeof window !== 'undefined') {
			(window as any).dispatchEvent(new CustomEvent('__ON_ORDER_PREVIEW_CHANGE__', {
				detail: {
					id: PREVIEW_ORDER_ID,
					price: previewOrder.type === OrderType.Limit ? previewOrder.limitPrice : previewOrder.stopPrice,
					takeProfit: previewOrder.takeProfit,
					stopLoss: previewOrder.stopLoss,
					qty: previewOrder.qty,
					source: 'panel'
				}
			}));
		}
	}
}
