import {
	AccountId,
	AccountManagerInfo,
	AccountManagerSummaryField,
	AccountMetainfo,
	ActionMetaInfo,
	Brackets,
	ConnectionStatus,
	DefaultContextMenuActionsParams,
	Execution,
	IBrokerConnectionAdapterHost,
	IDelegate,
	InstrumentInfo,
	IsTradableResult,
	IWatchedValue,
	MenuSeparator,
	Order,
	OrderStatus,
	OrderType,
	ParentType,
	PlaceOrderResult,
	Position,
	PreOrder,
	Side,
	StandardFormatterName,
	TradeContext,
} from '../../trading_platform-master/charting_library/broker-api';

import { IDatafeedQuotesApi, QuoteData } from '../../trading_platform-master/charting_library/datafeed-api';
import { AbstractBrokerMinimal } from '../../trading_platform-master/broker-sample/src/abstract-broker-minimal';
import { ordersPageColumns, positionsPageColumns } from '../../trading_platform-master/broker-sample/src/columns';
import { apiClient, positionsApi } from '@/lib/api';

interface SimpleMap<TValue> {
	[key: string]: TValue;
}

interface ApiPosition {
	id: string;
	ticket: number;
	symbol: string;
	type: 'Buy' | 'Sell' | 'Buy Limit' | 'Sell Limit' | 'Buy Stop' | 'Sell Stop';
	volume: number;
	openPrice: number;
	currentPrice: number;
	takeProfit?: number;
	stopLoss?: number;
	profit: number;
	orderType?: number;
}

// Helper function to change side (Buy <-> Sell)
function changeSide(side: Side): Side {
	return side === Side.Buy ? Side.Sell : Side.Buy;
}

// Safe host call wrapper
function safeHostCall(host: any, method: string, ...args: any[]): any {
	try {
		if (host && typeof host[method] === 'function') {
			return host[method](...args);
		}
	} catch (e) {
		console.warn('[ZuperiorBroker] Host call failed', method, e);
	}
	return undefined;
}

export class ZuperiorBroker extends AbstractBrokerMinimal {
	private _accountId: string | null;
	private _positions: Position[] = [];
	private _orders: Order[] = [];
	private _positionById: SimpleMap<Position> = {};
	private _orderById: SimpleMap<Order> = {};
	private _pollInterval: NodeJS.Timeout | null = null;
	private _isPolling = false;
	private _isWidgetReady = false;

	public constructor(host: IBrokerConnectionAdapterHost, quotesProvider: IDatafeedQuotesApi, accountId: string | null) {
		super(host, quotesProvider);
		this._accountId = accountId;
		// Start fetching immediately so positions()/orders() have data when TradingView queries
		this._startPolling();
	}

	public setWidgetReady(ready: boolean) {
		this._isWidgetReady = ready;
		if (ready) {
			// When widget becomes ready, trigger updates for all existing positions/orders
			this._notifyAllPositionsAndOrders();
			if (!this._isPolling) {
				this._startPolling();
			}
		}
	}

	public setAccountId(accountId: string | null) {
		if (this._accountId === accountId) return;

		console.log(`[ZuperiorBroker] Switching account from ${this._accountId} to ${accountId}`);
		this._accountId = accountId;

		// Clear existing data
		this._positions.length = 0;
		this._orders.length = 0;
		this._positionById = {};
		this._orderById = {};

		// Restart polling with new account
		if (this._isPolling) {
			this._fetchPositionsAndOrders();
		} else {
			this._startPolling();
		}
	}

	private _notifyAllPositionsAndOrders() {
		// Ensure arrays exist before filtering
		if (!Array.isArray(this._orders) || !Array.isArray(this._positions)) {
			console.warn('[ZuperiorBroker] Arrays not initialized, skipping notification');
			return;
		}

		// Separate bracket orders from regular orders
		const bracketOrders = this._orders.filter(o => o && o.parentId && o.parentType === ParentType.Position);
		const regularOrders = this._orders.filter(o => o && (!o.parentId || o.parentType !== ParentType.Position));

		// CRITICAL: Update bracket orders FIRST, then positions
		// This is the correct order for TradingView to display TP/SL lines

		// 1. Update bracket orders first
		bracketOrders.forEach(bracket => {
			try {
				if (this._host && typeof this._host.orderUpdate === 'function') {
					this._host.orderUpdate(bracket);
				}
			} catch (error) {
				console.error('[ZuperiorBroker] Error notifying bracket order:', error, bracket);
			}
		});

		// 2. Update regular orders
		regularOrders.forEach(o => {
			try {
				if (this._host && typeof this._host.orderUpdate === 'function') {
					this._host.orderUpdate(o);
				}
			} catch (error) {
				console.error('[ZuperiorBroker] Error notifying order:', error, o);
			}
		});

		// 3. Finally, update positions AFTER brackets exist
		this._positions.forEach(p => {
			try {
				if (this._host && typeof this._host.positionUpdate === 'function') {
					const cleanPosition = this._createCleanPosition(p);
					// Update _positionById with clean position before calling positionUpdate
					this._positionById[cleanPosition.id] = cleanPosition;
					this._host.positionUpdate(cleanPosition);
					if ((cleanPosition as any).pl !== undefined) {
						this._host.plUpdate(cleanPosition.symbol, (cleanPosition as any).pl);
					}
				}
			} catch (error) {
				console.error('[ZuperiorBroker] Error notifying position:', error, p);
			}
		});

		console.log(`[ZuperiorBroker] Notified TradingView: ${this._positions.length} positions, ${regularOrders.length} orders, ${bracketOrders.length} brackets`);
	}

	private async _startPolling() {
		if (this._isPolling || !this._accountId) return;
		this._isPolling = true;

		// Initial fetch
		await this._fetchPositionsAndOrders();

		// Poll every 2 seconds
		this._pollInterval = setInterval(() => {
			this._fetchPositionsAndOrders();
		}, 2000);
	}

	private async _fetchPositionsAndOrders() {
		if (!this._accountId) {
			console.log('[ZuperiorBroker] No accountId, skipping fetch');
			return;
		}

		try {
			console.log(`[ZuperiorBroker] Fetching positions/orders for accountId: ${this._accountId}`);
			const response = await apiClient.get<{
				success: boolean;
				positions?: any[];
				pendingOrders?: any[];
				data?: {
					positions?: any[];
					pendingOrders?: any[];
				};
			}>(`/api/positions/${this._accountId}`);

			// Check if response exists
			if (!response) {
				console.warn('[ZuperiorBroker] No response from API');
				return;
			}

			console.log('[ZuperiorBroker] API response:', {
				success: response?.success,
				positionsCount: response?.positions?.length || response?.data?.positions?.length || 0,
				pendingOrdersCount: response?.pendingOrders?.length || response?.data?.pendingOrders?.length || 0,
			});

			if (response && response.success) {
				// Ensure we have arrays, handle null/undefined cases
				// Ensure we have arrays, handle null/undefined cases
				// Check if response.data is an array (like usePositions handles it)
				let positionsSource = response.positions;
				if (!positionsSource && Array.isArray(response.data)) {
					positionsSource = response.data;
				} else if (!positionsSource && response.data?.positions) {
					positionsSource = response.data.positions;
				}

				const positionsArray = Array.isArray(positionsSource) ? positionsSource : [];

				let pendingSource = response.pendingOrders;
				if (!pendingSource && response.data?.pendingOrders) {
					pendingSource = response.data.pendingOrders;
				}

				const pendingArray = Array.isArray(pendingSource) ? pendingSource : [];

				console.log(`[ZuperiorBroker] Raw data - positions: ${positionsArray.length}, orders: ${pendingArray.length}`);

				// Debug: Log raw position data to see what fields are available
				if (positionsArray.length > 0) {
					console.log(`[ZuperiorBroker] Raw position data (first position):`, positionsArray[0]);
					console.log(`[ZuperiorBroker] All keys in first position:`, Object.keys(positionsArray[0] || {}));
					// Check for TP/SL in various formats
					const firstPos = positionsArray[0];
					if (firstPos) {
						console.log(`[ZuperiorBroker] TP/SL check:`, {
							takeProfit: firstPos.takeProfit,
							TakeProfit: firstPos.TakeProfit,
							TP: firstPos.TP,
							tp: firstPos.tp,
							stopLoss: firstPos.stopLoss,
							StopLoss: firstPos.StopLoss,
							SL: firstPos.SL,
							sl: firstPos.sl,
						});
					}
				}

				// Map positions - filter out invalid ones
				const tvPositions = (Array.isArray(positionsArray) ? positionsArray : [])
					.map((pos: any) => {
						try {
							return this._mapApiPositionToTVPosition(pos);
						} catch (error) {
							console.error('[ZuperiorBroker] Error mapping position:', error, pos);
							return null;
						}
					})
					.filter((p: Position | null): p is Position => p !== null && !!p.id && !!p.symbol && p.qty > 0 && p.avgPrice > 0);

				// Map pending orders - filter out invalid ones
				const tvOrders = (Array.isArray(pendingArray) ? pendingArray : [])
					.map((order: any) => {
						try {
							if (!order || typeof order !== 'object') {
								console.warn('[ZuperiorBroker] Invalid order object:', order);
								return null;
							}
							return this._mapApiOrderToTVOrder(order);
						} catch (error) {
							console.error('[ZuperiorBroker] Error mapping order:', error, order);
							return null;
						}
					})
					.filter((o: Order | null): o is Order => o !== null && !!o.id && !!o.symbol && o.qty > 0);

				// Create bracket orders for positions with TP/SL using helper methods
				const bracketOrders: Order[] = [];
				// Ensure tvPositions is an array before forEach
				if (Array.isArray(tvPositions)) {
					tvPositions.forEach(p => {
						// Ensure bracket fields are always present (even if undefined)
						if (!('stopLoss' in p)) {
							(p as any).stopLoss = undefined;
						}
						if (!('takeProfit' in p)) {
							(p as any).takeProfit = undefined;
						}

						// Validate bracket values are numbers
						if (p.stopLoss !== undefined && typeof p.stopLoss !== 'number') {
							const slNum = Number(p.stopLoss);
							(p as any).stopLoss = Number.isFinite(slNum) && slNum > 0 ? slNum : undefined;
						}
						if (p.takeProfit !== undefined && typeof p.takeProfit !== 'number') {
							const tpNum = Number(p.takeProfit);
							(p as any).takeProfit = Number.isFinite(tpNum) && tpNum > 0 ? tpNum : undefined;
						}

						// Create TP bracket order if takeProfit is set
						if (p.takeProfit && p.takeProfit > 0 && !isNaN(p.takeProfit) && isFinite(p.takeProfit)) {
							try {
								const tpBracket = this._createTakeProfitBracket(p);
								bracketOrders.push(tpBracket);
								console.log(`[ZuperiorBroker] Created TP bracket order: ${tpBracket.id} for position ${p.id}, limitPrice: ${tpBracket.limitPrice}`);
							} catch (error) {
								console.error('[ZuperiorBroker] Error creating TP bracket:', error);
							}
						}

						// Create SL bracket order if stopLoss is set
						if (p.stopLoss && p.stopLoss > 0 && !isNaN(p.stopLoss) && isFinite(p.stopLoss)) {
							try {
								const slBracket = this._createStopLossBracket(p);
								bracketOrders.push(slBracket);
								console.log(`[ZuperiorBroker] Created SL bracket order: ${slBracket.id} for position ${p.id}, stopPrice: ${slBracket.stopPrice}`);
							} catch (error) {
								console.error('[ZuperiorBroker] Error creating SL bracket:', error);
							}
						}
					});
				}

				// Combine pending orders with bracket orders
				// Ensure tvOrders is an array
				const allOrders = [...(Array.isArray(tvOrders) ? tvOrders : []), ...bracketOrders];

				// Update internal state - ensure arrays exist
				// CRITICAL: Store positions with TP/SL fields preserved
				if (Array.isArray(this._positions) && Array.isArray(tvPositions)) {
					this._positions.length = 0;
					// Ensure all positions have TP/SL fields before storing
					tvPositions.forEach(p => {
						// Verify TP/SL fields are present
						if (!('takeProfit' in p)) {
							(p as any).takeProfit = undefined;
						}
						if (!('stopLoss' in p)) {
							(p as any).stopLoss = undefined;
						}
					});
					this._positions.push(...tvPositions);

					// Debug: Log stored positions to verify TP/SL are preserved
					if (tvPositions.length > 0) {
						console.log(`[ZuperiorBroker] Stored positions with TP/SL:`, tvPositions.map(p => ({
							id: p.id,
							symbol: p.symbol,
							takeProfit: p.takeProfit,
							stopLoss: p.stopLoss,
						})));
					}
				} else {
					console.warn('[ZuperiorBroker] Cannot update positions - arrays not valid');
				}

				if (Array.isArray(this._orders) && Array.isArray(allOrders)) {
					this._orders.length = 0;
					this._orders.push(...allOrders);
				} else {
					console.warn('[ZuperiorBroker] Cannot update orders - arrays not valid');
				}

				// Update orderById map
				const orderMap: SimpleMap<Order> = {};
				if (Array.isArray(allOrders)) {
					allOrders.forEach(o => {
						if (o && o.id) {
							orderMap[o.id] = o;
						}
					});
				}
				this._orderById = orderMap;

				// Notify TradingView if widget is ready
				// CRITICAL: Update positions FIRST with brackets, THEN create bracket orders
				// This order is required for TradingView to show TP/SL buttons on trade lines
				if (this._isWidgetReady) {
					console.log(`[ZuperiorBroker] Widget ready, notifying TradingView: ${bracketOrders.length} brackets, ${tvOrders.length} orders, ${tvPositions.length} positions`);

					// Step 1: Create clean positions and update internal state BEFORE calling positionUpdate
					// CRITICAL: Store clean positions in _positionById and _positions BEFORE calling positionUpdate
					// This ensures positions() method returns valid data when TradingView queries it internally
					const cleanPositions: Position[] = [];
					const positionMap: SimpleMap<Position> = {};

					if (Array.isArray(tvPositions) && tvPositions.length > 0) {
						tvPositions.forEach(p => {
							try {
								// Validate position object before sending to TradingView
								if (!p || typeof p !== 'object') {
									console.warn('[ZuperiorBroker] Invalid position object:', p);
									return;
								}

								// Ensure all required fields are present and valid
								if (!p.id || typeof p.id !== 'string') {
									console.warn('[ZuperiorBroker] Position missing valid id:', p);
									return;
								}
								if (!p.symbol || typeof p.symbol !== 'string') {
									console.warn('[ZuperiorBroker] Position missing valid symbol:', p);
									return;
								}
								if (typeof p.qty !== 'number' || p.qty <= 0 || !isFinite(p.qty)) {
									console.warn('[ZuperiorBroker] Position missing valid qty:', p);
									return;
								}
								if (typeof p.side !== 'number' || (p.side !== Side.Buy && p.side !== Side.Sell)) {
									console.warn('[ZuperiorBroker] Position missing valid side:', p);
									return;
								}
								if (typeof p.avgPrice !== 'number' || p.avgPrice <= 0 || !isFinite(p.avgPrice)) {
									console.warn('[ZuperiorBroker] Position missing valid avgPrice:', p);
									return;
								}

								// Create a clean position object - brackets must be present (even if undefined)
								const cleanPosition = this._createCleanPosition(p);

								// Store clean position in arrays/maps
								cleanPositions.push(cleanPosition);
								positionMap[cleanPosition.id] = cleanPosition;
							} catch (error) {
								console.error('[ZuperiorBroker] Error creating clean position:', error, p);
							}
						});
					}

					// Update internal state with clean positions BEFORE calling positionUpdate
					// This ensures positions() returns correct data when TradingView queries it
					this._positions.length = 0;
					this._positions.push(...cleanPositions);
					this._positionById = positionMap;

					// Now notify TradingView with clean positions
					if (cleanPositions.length > 0) {
						cleanPositions.forEach(cleanPosition => {
							try {
								// Verify bracket fields are present before sending
								const hasTakeProfit = 'takeProfit' in cleanPosition;
								const hasStopLoss = 'stopLoss' in cleanPosition;
								console.log(`[ZuperiorBroker] Step 1: Sending position with brackets:`, {
									id: cleanPosition.id,
									symbol: cleanPosition.symbol,
									takeProfit: cleanPosition.takeProfit,
									stopLoss: cleanPosition.stopLoss,
									hasTakeProfitField: hasTakeProfit,
									hasStopLossField: hasStopLoss,
									positionKeys: Object.keys(cleanPosition),
								});

								if (this._host && typeof this._host.positionUpdate === 'function') {
									this._host.positionUpdate(cleanPosition);
								}
								if ((cleanPosition as any).pl !== undefined && typeof (cleanPosition as any).pl === 'number' && this._host && typeof this._host.plUpdate === 'function') {
									this._host.plUpdate(cleanPosition.symbol, (cleanPosition as any).pl);
								}
							} catch (error) {
								console.error('[ZuperiorBroker] Error updating position:', error, cleanPosition);
							}
						});
					} else {
						console.log(`[ZuperiorBroker] No positions to send (count: ${tvPositions.length})`);
					}

					// Step 2: Create bracket orders AFTER positions are updated
					// TradingView will match these to the position's brackets
					if (Array.isArray(bracketOrders) && bracketOrders.length > 0) {
						bracketOrders.forEach(bracket => {
							try {
								if (bracket && this._host && typeof this._host.orderUpdate === 'function') {
									console.log(`[ZuperiorBroker] Step 2: Sending bracket order:`, {
										id: bracket.id,
										symbol: bracket.symbol,
										type: bracket.type,
										parentId: bracket.parentId,
										limitPrice: (bracket as any).limitPrice,
										stopPrice: (bracket as any).stopPrice,
									});
									this._host.orderUpdate(bracket);
								}
							} catch (error) {
								console.error('[ZuperiorBroker] Error updating bracket order:', error, bracket);
							}
						});
					} else {
						console.log(`[ZuperiorBroker] No bracket orders to send (count: ${bracketOrders.length})`);
					}

					// Step 3: Update pending orders
					if (Array.isArray(tvOrders)) {
						tvOrders.forEach(o => {
							try {
								if (o && this._host && typeof this._host.orderUpdate === 'function') {
									this._host.orderUpdate(o);
								}
							} catch (error) {
								console.error('[ZuperiorBroker] Error updating order:', error, o);
							}
						});
					}
				}

				console.log(`[ZuperiorBroker] Updated ${tvPositions.length} positions, ${tvOrders.length} pending orders, ${bracketOrders.length} bracket orders`);
			}
		} catch (error) {
			console.error('[ZuperiorBroker] Error fetching positions/orders:', error);
		}
	}

	private _mapApiPositionToTVPosition(apiPos: any): Position {
		const ticket = apiPos.ticket || apiPos.Ticket || apiPos.PositionId || apiPos.id;
		const id = String(ticket);

		// Map side: Buy = 1, Sell = -1
		// FIXED: Correct side mapping logic to match open positions table
		const typeStr = (apiPos.type || apiPos.Type || '').toString();
		const action = apiPos.Action || apiPos.action;

		// Primary check: use type field directly if it's a string
		let isBuy = false;
		if (typeStr === 'Buy') {
			isBuy = true;
		} else if (typeStr === 'Sell') {
			isBuy = false;
		} else if (action !== undefined) {
			// Fallback: use action field (0 = Buy, 1 = Sell)
			isBuy = action === 0 || String(action) === '0';
		} else {
			// Last resort: check if type contains 'buy'
			isBuy = typeStr.toLowerCase().includes('buy');
		}

		const side = isBuy ? Side.Buy : Side.Sell;

		const openPrice = Number(apiPos.openPrice || apiPos.OpenPrice || apiPos.priceOpen || apiPos.PriceOpen || apiPos.price || apiPos.Price || 0);
		const currentPrice = Number(apiPos.currentPrice || apiPos.CurrentPrice || apiPos.priceCurrent || apiPos.PriceCurrent || apiPos.price || apiPos.Price || openPrice);

		// Fix volume logic: Divide by 10000 to match open positions table
		// This matches the TradingTerminal volume formatting: (pos.volume / 10000).toFixed(2)
		let volume = 0;
		const volumeLots = apiPos.VolumeLots || apiPos.volumeLots;
		const rawVolume = apiPos.Volume || apiPos.volume || 0;

		if (volumeLots !== undefined && volumeLots !== null) {
			volume = Number(volumeLots);
		} else {
			const numVolume = Math.abs(Number(rawVolume));
			// Always divide by 10000 to match open positions table
			volume = numVolume / 10000;
		}

		const profit = Number(apiPos.profit || apiPos.Profit || apiPos.pl || apiPos.PL || 0);

		// Ensure all required fields are valid
		// Use raw symbol from API without normalization to match chart symbol (e.g. EURJPYm)
		const symbol = (apiPos.symbol || apiPos.Symbol || '').toUpperCase();

		if (!symbol || !id || volume <= 0 || openPrice <= 0) {
			console.warn('[ZuperiorBroker] Invalid position data:', { id, symbol, rawVolume, volume, openPrice });
		}

		// Ensure all required fields are valid before creating position
		if (!id || !symbol || volume <= 0 || openPrice <= 0) {
			console.warn('[ZuperiorBroker] Cannot create position - missing required fields:', { id, symbol, volume, openPrice });
			// Return a minimal valid position to avoid crashes, but it will be filtered out
			return {
				id: id || 'invalid',
				symbol: symbol || 'UNKNOWN',
				qty: Math.max(volume, 0.01),
				side,
				avgPrice: Math.max(openPrice, 0.01),
			} as Position;
		}

		const position: Position = {
			id: String(id),
			symbol: String(symbol).toUpperCase(),
			qty: Number(volume),
			side: Number(side),
			avgPrice: Number(openPrice),
		} as Position;

		// Add optional fields only if they have valid values
		if (currentPrice > 0 && !isNaN(currentPrice)) {
			(position as any).last = Number(currentPrice);
		}
		if (profit !== 0 && !isNaN(profit) && isFinite(profit)) {
			(position as any).pl = Number(profit);
		}
		// FIXED: Extract TP/SL from multiple field name variations with better validation
		// Check all possible field name variations (case-insensitive, snake_case, camelCase, etc.)
		const takeProfitRaw = apiPos.takeProfit ?? apiPos.TakeProfit ?? apiPos.TP ?? apiPos.tp ??
			apiPos.take_profit ?? apiPos.Take_Profit ?? apiPos.TAKE_PROFIT ??
			apiPos.takeProfitPrice ?? apiPos.TakeProfitPrice ?? apiPos.tpPrice ?? apiPos.TPPrice ??
			apiPos.PriceTP ?? apiPos.priceTP;

		const takeProfitNum = (takeProfitRaw !== undefined && takeProfitRaw !== null && takeProfitRaw !== '' && takeProfitRaw !== 0)
			? (typeof takeProfitRaw === 'string' ? parseFloat(takeProfitRaw) : Number(takeProfitRaw))
			: NaN;
		// Only include valid positive numbers for TP/SL
		const takeProfit = Number.isFinite(takeProfitNum) && takeProfitNum > 0 ? takeProfitNum : undefined;

		const stopLossRaw = apiPos.stopLoss ?? apiPos.StopLoss ?? apiPos.SL ?? apiPos.sl ??
			apiPos.stop_loss ?? apiPos.Stop_Loss ?? apiPos.STOP_LOSS ??
			apiPos.stopLossPrice ?? apiPos.StopLossPrice ?? apiPos.slPrice ?? apiPos.SLPrice ??
			apiPos.PriceSL ?? apiPos.priceSL;

		const stopLossNum = (stopLossRaw !== undefined && stopLossRaw !== null && stopLossRaw !== '' && stopLossRaw !== 0)
			? (typeof stopLossRaw === 'string' ? parseFloat(stopLossRaw) : Number(stopLossRaw))
			: NaN;
		// Only include valid positive numbers for TP/SL
		const stopLoss = Number.isFinite(stopLossNum) && stopLossNum > 0 ? stopLossNum : undefined;

		// Debug logging to see what we're getting from API - log for ALL positions to help debug
		console.log(`[ZuperiorBroker] TP/SL extraction for position ${id}:`, {
			takeProfitRaw,
			takeProfit,
			takeProfitNum,
			stopLossRaw,
			stopLoss,
			stopLossNum,
			allApiKeys: Object.keys(apiPos),
			// Log all potential TP/SL fields
			apiTakeProfit: apiPos.takeProfit,
			apiTP: apiPos.TP,
			apiStopLoss: apiPos.stopLoss,
			apiSL: apiPos.SL,
		});

		// Set TP/SL fields - ensure they are numbers (not strings) or null for TradingView brackets
		// CRITICAL: Always set these fields, even if null, so Account Manager can display columns
		position.takeProfit = takeProfit !== undefined ? Number(takeProfit) : null;
		position.stopLoss = stopLoss !== undefined ? Number(stopLoss) : null;

		// Add all additional fields required by app's position table
		// These fields are extracted from API response to match usePositions hook format

		// ticket field - required by app
		(position as any).ticket = Number(ticket) || 0;

		// type field as string (Buy/Sell) - required by app
		(position as any).type = isBuy ? 'Buy' : 'Sell';

		// volume field (alias for qty) - app uses 'volume'
		(position as any).volume = Number(volume);

		// openPrice field (alias for avgPrice) - app uses 'openPrice'
		(position as any).openPrice = Number(openPrice);

		// currentPrice field - required for P&L calculation
		(position as any).currentPrice = Number(currentPrice);

		// swap field - required by app
		(position as any).swap = Number(apiPos.swap || apiPos.Swap || 0);

		// commission field - required by app
		(position as any).commission = Number(apiPos.commission || apiPos.Commission || 0);

		// comment field - required by app
		(position as any).comment = apiPos.comment || apiPos.Comment || undefined;

		// openTime field - required by app
		const openTime = apiPos.openTime || apiPos.OpenTime || apiPos.TimeCreate || apiPos.timeCreate ||
			apiPos.TimeSetup || apiPos.timeSetup || new Date().toISOString();
		(position as any).openTime = String(openTime);

		// openTimeInMs field - required by TradingView for proper chart display
		// Convert ISO string to milliseconds timestamp
		let openTimeMs = Date.now();
		try {
			openTimeMs = new Date(openTime).getTime();
		} catch (e) {
			console.warn('[ZuperiorBroker] Failed to parse openTime:', openTime);
		}
		(position as any).openTimeInMs = openTimeMs;

		// positionId field - app uses this
		(position as any).positionId = Number(apiPos.PositionId || apiPos.positionId || ticket) || undefined;

		// Ensure bracket fields are always present (even if undefined)
		// This is required for TradingView Account Manager to show TP/SL columns
		if (!('stopLoss' in position)) {
			position.stopLoss = undefined;
		}
		if (!('takeProfit' in position)) {
			position.takeProfit = undefined;
		}

		// Final verification - log if values are missing but should be there
		if (takeProfitRaw !== undefined && takeProfitRaw !== null && takeProfit === undefined) {
			console.warn(`[ZuperiorBroker] TP value lost during extraction for position ${id}:`, {
				raw: takeProfitRaw,
				parsed: takeProfitNum,
				isFinite: Number.isFinite(takeProfitNum),
				isPositive: takeProfitNum > 0,
			});
		}
		if (stopLossRaw !== undefined && stopLossRaw !== null && stopLoss === undefined) {
			console.warn(`[ZuperiorBroker] SL value lost during extraction for position ${id}:`, {
				raw: stopLossRaw,
				parsed: stopLossNum,
				isFinite: Number.isFinite(stopLossNum),
				isPositive: stopLossNum > 0,
			});
		}

		return position;
	}

	private _mapApiOrderToTVOrder(apiOrder: any): Order {
		const ticket = apiOrder.ticket || apiOrder.Ticket || apiOrder.OrderId || apiOrder.id;
		const id = String(ticket);

		// Map order type
		const orderType = apiOrder.orderType || apiOrder.Type || apiOrder.type;
		let type: OrderType;
		if (typeof orderType === 'number') {
			if (orderType === 2 || orderType === 3) type = OrderType.Limit; // Buy Limit, Sell Limit
			else if (orderType === 4 || orderType === 5) type = OrderType.Stop; // Buy Stop, Sell Stop
			else type = OrderType.Market;
		} else {
			type = OrderType.Market;
		}

		// Map side
		const isBuy = apiOrder.type === 'Buy' || apiOrder.type === 'Buy Limit' || apiOrder.type === 'Buy Stop' ||
			apiOrder.Action === 0 || apiOrder.action === 0;
		const side = isBuy ? Side.Buy : Side.Sell;

		// Determine price fields
		const openPrice = Number(apiOrder.openPrice || apiOrder.OpenPrice || apiOrder.priceOrder || apiOrder.PriceOrder || 0);
		const limitPrice = (type === OrderType.Limit) ? openPrice : undefined;
		const stopPrice = (type === OrderType.Stop) ? openPrice : undefined;

		// Use raw volume to match usePositions hook
		const rawVolume = Number(apiOrder.volume || apiOrder.Volume || 0);
		const volume = rawVolume;

		return {
			id,
			symbol: apiOrder.symbol || apiOrder.Symbol || '',
			type,
			side,
			qty: volume,
			status: OrderStatus.Working,
			limitPrice,
			stopPrice,
			takeProfit: apiOrder.takeProfit || apiOrder.TakeProfit || apiOrder.TP || apiOrder.tp || undefined,
			stopLoss: apiOrder.stopLoss || apiOrder.StopLoss || apiOrder.SL || apiOrder.sl || undefined,
		} as Order;
	}

	public connectionStatus(): ConnectionStatus {
		return ConnectionStatus.Connected;
	}

	public currentAccount(): AccountId {
		return (this._accountId || '1') as AccountId;
	}

	public async isTradable(_symbol: string): Promise<boolean | IsTradableResult> {
		return Promise.resolve(true);
	}

	public async symbolInfo(symbol: string): Promise<InstrumentInfo> {
		// Get min tick from host if available
		const mintick = await this._host.getSymbolMinTick(symbol).catch(() => 0.01);
		const pipSize = mintick;
		const accountCurrencyRate = 1;
		const pointValue = 1;

		return {
			qty: {
				min: 0.01,
				max: 1e12,
				step: 0.01,
			},
			pipValue: pipSize * pointValue * accountCurrencyRate || 1,
			pipSize: pipSize,
			minTick: mintick,
			description: '',
		};
	}

	public async orders(): Promise<Order[]> {
		// Ensure _orders is always an array before calling slice()
		if (!Array.isArray(this._orders)) {
			console.warn('[ZuperiorBroker] _orders is not an array, returning empty array');
			return Promise.resolve([]);
		}

		// Start with pending orders from API
		const orders = this._orders.slice();

		// Synthesize bracket orders for all open positions
		// This ensures TP/SL lines appear on the chart even after refresh
		if (Array.isArray(this._positions)) {
			this._positions.forEach(position => {
				// Create TP bracket if exists and is valid
				if (position.takeProfit !== undefined && position.takeProfit !== null && position.takeProfit > 0) {
					const tpOrder: Order = {
						id: `tp_${position.id}`,
						symbol: position.symbol,
						qty: position.qty,
						parentId: position.id,
						parentType: ParentType.Position,
						limitPrice: Number(position.takeProfit),
						side: changeSide(position.side),
						status: OrderStatus.Working,
						type: OrderType.Limit,
					} as Order;

					// Add profit if available
					if ((position as any).pl !== undefined) {
						(tpOrder as any).pl = (position as any).pl;
					}

					orders.push(tpOrder);
				}

				// Create SL bracket if exists and is valid
				if (position.stopLoss !== undefined && position.stopLoss !== null && position.stopLoss > 0) {
					const slOrder: Order = {
						id: `sl_${position.id}`,
						symbol: position.symbol,
						qty: position.qty,
						parentId: position.id,
						parentType: ParentType.Position,
						stopPrice: Number(position.stopLoss),
						price: Number(position.stopLoss),
						side: changeSide(position.side),
						status: OrderStatus.Working,
						type: OrderType.Stop,
					} as Order;

					// Add profit if available
					if ((position as any).pl !== undefined) {
						(slOrder as any).pl = (position as any).pl;
					}

					orders.push(slOrder);
				}
			});
		}

		console.log(`[ZuperiorBroker] orders() called, returning ${orders.length} orders (including brackets)`);
		return Promise.resolve(orders);
	}

	// CRITICAL: Add this method for bracket functionality
	public getBrackets(parentId: string): Order[] {
		return this._orders.filter(
			(order: Order) => order.parentId === parentId &&
				(order.status === OrderStatus.Working || order.status === OrderStatus.Inactive)
		);
	}

	// CRITICAL: Add modifyOrder method for draggable TP/SL
	public async modifyOrder(order: Order, _confirmId?: string): Promise<void> {
		console.log('[ZuperiorBroker] modifyOrder called:', order);

		// Get the original order
		const originalOrder = this._orderById[order.id];
		if (!originalOrder) {
			return;
		}

		// Update local state
		Object.assign(this._orderById[order.id], order);

		// Update orders array
		const orderIndex = this._orders.findIndex(o => o.id === order.id);
		if (orderIndex >= 0) {
			this._orders[orderIndex] = order;
		}

		// Notify TradingView
		if (this._host && typeof this._host.orderUpdate === 'function') {
			this._host.orderUpdate(order);
		}

		// Handle bracket updates
		if (order.parentId !== undefined) {
			const entity = order.parentType === ParentType.Position
				? this._positionById[order.parentId]
				: this._orderById[order.parentId];

			if (entity) {
				// Update TP/SL on parent
				if (order.limitPrice !== undefined) {
					(entity as any).takeProfit = order.limitPrice;
				}
				if (order.stopPrice !== undefined) {
					(entity as any).stopLoss = order.stopPrice;
				}

				// Update parent position
				if (order.parentType === ParentType.Position) {
					const cleanPosition = this._createCleanPosition(entity as Position);
					this._positionById[cleanPosition.id] = cleanPosition;
					if (this._host && typeof this._host.positionUpdate === 'function') {
						this._host.positionUpdate(cleanPosition);
					}
				}
			}
		}
	}

	public async positions(): Promise<Position[]> {
		// Ensure _positions is always an array before calling slice()
		if (!Array.isArray(this._positions)) {
			console.warn('[ZuperiorBroker] _positions is not an array, returning empty array');
			return Promise.resolve([]);
		}

		// CRITICAL: Ensure all positions have TP/SL fields (even if undefined) for Account Manager
		// TradingView Account Manager needs these fields to display Stop Loss and Take Profit columns
		const positions = this._positions.map(p => {
			// Create clean position to ensure all fields are present
			const clean = this._createCleanPosition(p);
			return clean;
		});

		console.log(`[ZuperiorBroker] positions() called, returning ${positions.length} positions`);
		if (positions.length > 0) {
			console.log('[ZuperiorBroker] Sample position for Account Manager:', {
				id: positions[0].id,
				symbol: positions[0].symbol,
				qty: positions[0].qty,
				side: positions[0].side,
				avgPrice: positions[0].avgPrice,
				takeProfit: positions[0].takeProfit,
				stopLoss: positions[0].stopLoss,
				hasTakeProfit: 'takeProfit' in positions[0],
				hasStopLoss: 'stopLoss' in positions[0],
			});
		}
		return Promise.resolve(positions);
	}

	public async individualPositions(): Promise<Position[]> {
		// Return individual positions (same as positions() since we don't use netting)
		const positions = await this.positions();
		console.log(`[ZuperiorBroker] individualPositions() called, returning ${positions.length} individual positions`);
		return positions;
	}

	public async executions(_symbol: string): Promise<Execution[]> {
		return Promise.resolve([]);
	}

	public async placeOrder(preOrder: PreOrder): Promise<PlaceOrderResult> {
		console.log('[ZuperiorBroker] placeOrder called:', preOrder);

		if (!this._accountId) {
			throw new Error('No account ID');
		}

		try {
			const token = apiClient.getToken();
			const baseURL = process.env.NEXT_PUBLIC_BACKEND_API_URL ||
				(process.env.NEXT_PUBLIC_API_BASE_URL && process.env.NEXT_PUBLIC_API_BASE_URL.includes('localhost')
					? process.env.NEXT_PUBLIC_API_BASE_URL
					: 'http://localhost:5000');

			// Map TV PreOrder to backend payload
			// TV PreOrder: { symbol, qty, side (1/-1), type (1=Limit, 2=Market, 3=Stop), limitPrice, stopPrice, takeProfit, stopLoss }

			const side = preOrder.side === 1 ? 'buy' : 'sell';
			const isMarket = preOrder.type === 2; // Market

			let endpoint = '';
			let payload: any = {};

			if (isMarket) {
				endpoint = '/api/orders/market';
				payload = {
					accountId: this._accountId,
					symbol: preOrder.symbol,
					side: side,
					volume: preOrder.qty,
					stopLoss: preOrder.stopLoss,
					takeProfit: preOrder.takeProfit,
				};
			} else {
				// Pending Order (Limit or Stop)
				endpoint = '/api/orders/pending';

				let orderType = 'limit';
				let price = 0;

				if (preOrder.type === 1) { // Limit
					orderType = 'limit';
					price = preOrder.limitPrice || 0;
				} else if (preOrder.type === 3) { // Stop
					orderType = 'stop';
					price = preOrder.stopPrice || 0;
				} else if (preOrder.type === 4) { // StopLimit
					orderType = 'stop'; // Backend might treat stop-limit as stop for now, or needs specific handling
					price = preOrder.limitPrice || 0;
				}

				payload = {
					accountId: this._accountId,
					symbol: preOrder.symbol,
					side: side,
					volume: preOrder.qty,
					price: price,
					orderType: orderType,
					stopLoss: preOrder.stopLoss,
					takeProfit: preOrder.takeProfit,
				};
			}

			console.log(`[ZuperiorBroker] Sending order to backend (${endpoint}):`, payload);

			const response = await fetch(`${baseURL}${endpoint}`, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					...(token ? { 'Authorization': `Bearer ${token}` } : {}),
				},
				body: JSON.stringify(payload),
			});

			if (!response.ok) {
				const errorData = await response.json().catch(() => ({ message: response.statusText }));
				throw new Error(errorData.message || `Failed to place order: ${response.statusText}`);
			}

			const result = await response.json();
			console.log('[ZuperiorBroker] Order placed successfully:', result);

			// Refresh data
			this._fetchPositionsAndOrders();

			return { orderId: result.orderId || result.id || 'unknown' };
		} catch (error) {
			console.error('[ZuperiorBroker] Error placing order:', error);
			throw error;
		}
	}



	public async cancelOrder(orderId: string): Promise<void> {
		if (!this._accountId) {
			throw new Error('No account ID');
		}

		try {
			// Call API to cancel order - use fetch directly since we need DELETE with body
			const token = apiClient.getToken();
			// Get base URL from environment or default to localhost:5000
			const baseURL = process.env.NEXT_PUBLIC_BACKEND_API_URL ||
				(process.env.NEXT_PUBLIC_API_BASE_URL && process.env.NEXT_PUBLIC_API_BASE_URL.includes('localhost')
					? process.env.NEXT_PUBLIC_API_BASE_URL
					: 'http://localhost:5000');

			const response = await fetch(`${baseURL}/api/trading/pending/order/${orderId}`, {
				method: 'DELETE',
				headers: {
					'Content-Type': 'application/json',
					...(token ? { 'Authorization': `Bearer ${token}` } : {}),
				},
				body: JSON.stringify({
					accountId: this._accountId,
					comment: 'Cancel via chart',
				}),
			});

			if (!response.ok) {
				throw new Error(`Failed to cancel order: ${response.statusText}`);
			}

			// Remove from local state
			const orderIndex = this._orders.findIndex(o => o.id === orderId);
			if (orderIndex >= 0) {
				this._orders.splice(orderIndex, 1);
				delete this._orderById[orderId];
			}

			// Refresh positions/orders
			await this._fetchPositionsAndOrders();
		} catch (error) {
			console.error('[ZuperiorBroker] Error canceling order:', error);
			throw error;
		}
	}

	public async closePosition(positionId: string): Promise<void> {
		if (!this._accountId) {
			throw new Error('No account ID');
		}

		try {
			// Call API to close position - use fetch directly for DELETE with body
			const position = this._positionById[positionId];
			if (!position) {
				throw new Error('Position not found');
			}

			const token = apiClient.getToken();
			const baseURL = process.env.NEXT_PUBLIC_BACKEND_API_URL ||
				(process.env.NEXT_PUBLIC_API_BASE_URL && process.env.NEXT_PUBLIC_API_BASE_URL.includes('localhost')
					? process.env.NEXT_PUBLIC_API_BASE_URL
					: 'http://localhost:5000');

			const response = await fetch(`${baseURL}/api/trading/close`, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					...(token ? { 'Authorization': `Bearer ${token}` } : {}),
				},
				body: JSON.stringify({
					accountId: this._accountId,
					positionId: positionId,
					symbol: position.symbol,
				}),
			});

			if (!response.ok) {
				const errorData = await response.json().catch(() => ({ message: response.statusText }));
				throw new Error(errorData.message || `Failed to close position: ${response.statusText}`);
			}

			// Remove from local state
			const posIndex = this._positions.findIndex(p => p.id === positionId);
			if (posIndex >= 0) {
				this._positions.splice(posIndex, 1);
				delete this._positionById[positionId];
			}

			// Refresh positions/orders
			await this._fetchPositionsAndOrders();
		} catch (error) {
			console.error('[ZuperiorBroker] Error closing position:', error);
			throw error;
		}
	}

	public async editPositionBrackets(positionId: string, modifiedBrackets: Brackets): Promise<void> {
		console.log('[ZuperiorBroker] editPositionBrackets called:', {
			positionId,
			brackets: {
				stopLoss: modifiedBrackets.stopLoss !== undefined ? modifiedBrackets.stopLoss : 'undefined',
				takeProfit: modifiedBrackets.takeProfit !== undefined ? modifiedBrackets.takeProfit : 'undefined',
			},
		});

		if (!this._accountId) {
			throw new Error('No account ID');
		}

		if (!positionId) {
			throw new Error('Position ID is required');
		}

		try {
			// Extract bracket values - handle null/undefined/0 (which means remove bracket)
			const stopLossValue = modifiedBrackets.stopLoss !== undefined && modifiedBrackets.stopLoss !== null && Number(modifiedBrackets.stopLoss) > 0
				? Number(modifiedBrackets.stopLoss)
				: undefined;
			const takeProfitValue = modifiedBrackets.takeProfit !== undefined && modifiedBrackets.takeProfit !== null && Number(modifiedBrackets.takeProfit) > 0
				? Number(modifiedBrackets.takeProfit)
				: undefined;

			// Get current position
			let position: Position | undefined = this._positionById[positionId];
			if (!position) {
				// Try to get from positions array
				const positions = await this.positions();
				position = positions.find(p => p.id === positionId);
			}

			if (!position) {
				throw new Error('Position not found');
			}

			// CRITICAL: Preserve unchanged brackets when only one is modified
			let finalStopLoss = stopLossValue;
			let finalTakeProfit = takeProfitValue;

			// If only one bracket is being modified, preserve the other from current position
			if (stopLossValue === undefined && takeProfitValue !== undefined) {
				// Only TP is being modified - preserve current SL
				if (position.stopLoss !== undefined && position.stopLoss !== null) {
					finalStopLoss = Number(position.stopLoss);
					console.log('[ZuperiorBroker] Preserving existing SL:', finalStopLoss);
				}
			} else if (takeProfitValue === undefined && stopLossValue !== undefined) {
				// Only SL is being modified - preserve current TP
				if (position.takeProfit !== undefined && position.takeProfit !== null) {
					finalTakeProfit = Number(position.takeProfit);
					console.log('[ZuperiorBroker] Preserving existing TP:', finalTakeProfit);
				}
			}

			// Call API to update position
			const token = apiClient.getToken();
			const baseURL = process.env.NEXT_PUBLIC_BACKEND_API_URL ||
				(process.env.NEXT_PUBLIC_API_BASE_URL && process.env.NEXT_PUBLIC_API_BASE_URL.includes('localhost')
					? process.env.NEXT_PUBLIC_API_BASE_URL
					: 'http://localhost:5000');

			// Use the correct endpoint for modifying positions found in backend routes
			const response = await fetch(`${baseURL}/api/positions/${positionId}/modify`, {
				method: 'PUT',
				headers: {
					'Content-Type': 'application/json',
					...(token ? { 'Authorization': `Bearer ${token}` } : {}),
				},
				body: JSON.stringify({
					accountId: this._accountId,
					stopLoss: finalStopLoss,
					takeProfit: finalTakeProfit,
				}),
			});

			if (!response.ok) {
				const errorData = await response.json().catch(() => ({ message: response.statusText }));
				throw new Error(errorData.message || `Failed to update position brackets: ${response.statusText}`);
			}

			// Update local position state
			position.stopLoss = finalStopLoss;
			position.takeProfit = finalTakeProfit;
			this._positionById[positionId] = position;

			// 1. Notify Position Update
			if (this._host && typeof this._host.positionUpdate === 'function') {
				const cleanPosition = this._createCleanPosition(position);
				this._host.positionUpdate(cleanPosition);
			}

			// 2. Handle Take Profit Bracket
			if (finalTakeProfit !== undefined) {
				const tpOrder: Order = {
					id: `tp_${positionId}`,
					symbol: position.symbol,
					qty: position.qty,
					parentId: positionId,
					parentType: ParentType.Position,
					limitPrice: finalTakeProfit,
					side: changeSide(position.side),
					status: OrderStatus.Working, // Must be Working for brackets on position
					type: OrderType.Limit,
				} as Order;

				// Add profit if available (for display on line)
				if ((position as any).pl !== undefined) {
					(tpOrder as any).pl = (position as any).pl;
				}

				this._orderById[tpOrder.id] = tpOrder;
				if (this._host && typeof this._host.orderUpdate === 'function') {
					this._host.orderUpdate(tpOrder);
				}
			} else {
				// If TP removed, we should probably cancel the existing TP bracket if we tracked it
				// For now, we just don't send an update, or we could send Canceled if we knew the ID
				// But since IDs are deterministic (tp_...), we can try to cancel
				const tpId = `tp_${positionId}`;
				if (this._orderById[tpId]) {
					const tpOrder = this._orderById[tpId];
					tpOrder.status = OrderStatus.Canceled;
					if (this._host && typeof this._host.orderUpdate === 'function') {
						this._host.orderUpdate(tpOrder);
					}
					delete this._orderById[tpId];
				}
			}

			// 3. Handle Stop Loss Bracket
			if (finalStopLoss !== undefined) {
				const slOrder: Order = {
					id: `sl_${positionId}`,
					symbol: position.symbol,
					qty: position.qty,
					parentId: positionId,
					parentType: ParentType.Position,
					stopPrice: finalStopLoss,
					price: finalStopLoss, // Required for stop orders sometimes
					side: changeSide(position.side),
					status: OrderStatus.Working, // Must be Working for brackets on position
					type: OrderType.Stop,
				} as Order;

				// Add profit if available
				if ((position as any).pl !== undefined) {
					(slOrder as any).pl = (position as any).pl;
				}

				this._orderById[slOrder.id] = slOrder;
				if (this._host && typeof this._host.orderUpdate === 'function') {
					this._host.orderUpdate(slOrder);
				}
			} else {
				// If SL removed
				const slId = `sl_${positionId}`;
				if (this._orderById[slId]) {
					const slOrder = this._orderById[slId];
					slOrder.status = OrderStatus.Canceled;
					if (this._host && typeof this._host.orderUpdate === 'function') {
						this._host.orderUpdate(slOrder);
					}
					delete this._orderById[slId];
				}
			}

			// Refresh all data to be sure
			this._fetchPositionsAndOrders();

			// Optionally trigger modify modal if available
			if (typeof window !== 'undefined' && (window as any).__OPEN_MODIFY_POSITION_MODAL__) {
				(window as any).__OPEN_MODIFY_POSITION_MODAL__(position, {
					stopLoss: finalStopLoss,
					takeProfit: finalTakeProfit,
				});
			}

			// Refresh positions/orders to sync with backend
			await this._fetchPositionsAndOrders();
		} catch (error) {
			console.error('[ZuperiorBroker] Error editing position brackets:', error);
			throw error;
		}
	}

	public async editIndividualPositionBrackets(positionId: string, modifiedBrackets: Brackets, customFields?: any): Promise<void> {
		console.log('[ZuperiorBroker] editIndividualPositionBrackets called:', {
			positionId,
			brackets: {
				stopLoss: modifiedBrackets.stopLoss !== undefined ? modifiedBrackets.stopLoss : 'undefined',
				takeProfit: modifiedBrackets.takeProfit !== undefined ? modifiedBrackets.takeProfit : 'undefined',
			},
		});

		if (!this._accountId) {
			throw new Error('No account ID');
		}

		if (!positionId) {
			throw new Error('Position ID is required');
		}

		try {
			// Get current position
			let position: Position | undefined = this._positionById[positionId];
			if (!position) {
				const positions = await this.positions();
				position = positions.find(p => p.id === positionId);
			}

			if (!position) {
				throw new Error('Position not found');
			}

			// Extract bracket values
			const stopLossValue = modifiedBrackets.stopLoss !== undefined && modifiedBrackets.stopLoss !== null && Number(modifiedBrackets.stopLoss) > 0
				? Number(modifiedBrackets.stopLoss)
				: null;
			const takeProfitValue = modifiedBrackets.takeProfit !== undefined && modifiedBrackets.takeProfit !== null && Number(modifiedBrackets.takeProfit) > 0
				? Number(modifiedBrackets.takeProfit)
				: null;

			// Call backend API
			const token = apiClient.getToken();
			const baseURL = process.env.NEXT_PUBLIC_BACKEND_API_URL ||
				(process.env.NEXT_PUBLIC_API_BASE_URL && process.env.NEXT_PUBLIC_API_BASE_URL.includes('localhost')
					? process.env.NEXT_PUBLIC_API_BASE_URL
					: 'http://localhost:5000');

			const response = await fetch(`${baseURL}/api/positions/${positionId}/modify`, {
				method: 'PUT',
				headers: {
					'Content-Type': 'application/json',
					...(token ? { 'Authorization': `Bearer ${token}` } : {}),
				},
				body: JSON.stringify({
					accountId: this._accountId,
					stopLoss: stopLossValue,
					takeProfit: takeProfitValue,
				}),
			});

			if (!response.ok) {
				const errorData = await response.json().catch(() => ({ message: response.statusText }));
				throw new Error(errorData.message || `Failed to update position brackets: ${response.statusText}`);
			}

			// Update position locally
			position.stopLoss = stopLossValue;
			position.takeProfit = takeProfitValue;
			this._positionById[positionId] = position;

			// CRITICAL: Call individualPositionUpdate (not positionUpdate) for individual positions
			if (this._host && typeof this._host.individualPositionUpdate === 'function') {
				const cleanPosition = this._createCleanPosition(position);
				this._host.individualPositionUpdate(cleanPosition);
			} else if (this._host && typeof this._host.positionUpdate === 'function') {
				// Fallback to positionUpdate if individualPositionUpdate not available
				const cleanPosition = this._createCleanPosition(position);
				this._host.positionUpdate(cleanPosition);
			}

			// Update bracket orders
			if (takeProfitValue !== null) {
				const tpOrder: Order = {
					id: `tp_${positionId}`,
					symbol: position.symbol,
					qty: position.qty,
					parentId: positionId,
					parentType: ParentType.Position,
					limitPrice: takeProfitValue,
					side: changeSide(position.side),
					status: OrderStatus.Working,
					type: OrderType.Limit,
				} as Order;

				this._orderById[tpOrder.id] = tpOrder;
				if (this._host && typeof this._host.orderUpdate === 'function') {
					this._host.orderUpdate(tpOrder);
				}
			} else {
				// Remove TP bracket
				const tpId = `tp_${positionId}`;
				if (this._orderById[tpId]) {
					const tpOrder = this._orderById[tpId];
					tpOrder.status = OrderStatus.Canceled;
					if (this._host && typeof this._host.orderUpdate === 'function') {
						this._host.orderUpdate(tpOrder);
					}
					delete this._orderById[tpId];
				}
			}

			if (stopLossValue !== null) {
				const slOrder: Order = {
					id: `sl_${positionId}`,
					symbol: position.symbol,
					qty: position.qty,
					parentId: positionId,
					parentType: ParentType.Position,
					stopPrice: stopLossValue,
					price: stopLossValue,
					side: changeSide(position.side),
					status: OrderStatus.Working,
					type: OrderType.Stop,
				} as Order;

				this._orderById[slOrder.id] = slOrder;
				if (this._host && typeof this._host.orderUpdate === 'function') {
					this._host.orderUpdate(slOrder);
				}
			} else {
				// Remove SL bracket
				const slId = `sl_${positionId}`;
				if (this._orderById[slId]) {
					const slOrder = this._orderById[slId];
					slOrder.status = OrderStatus.Canceled;
					if (this._host && typeof this._host.orderUpdate === 'function') {
						this._host.orderUpdate(slOrder);
					}
					delete this._orderById[slId];
				}
			}

		} catch (error) {
			console.error('[ZuperiorBroker] Error editing individual position brackets:', error);
			throw error;
		}
	}

	public async reversePosition(positionId: string): Promise<void> {
		// Reverse position by closing and opening opposite side
		const position = this._positionById[positionId];
		if (!position) {
			throw new Error('Position not found');
		}

		// Close current position first, then the placeOrder will handle reversal
		await this.closePosition(positionId);
		// Note: Actual reversal logic would place an order in opposite direction with 2x quantity
		// For now, we'll just close and let user place new order if needed
	}

	public accountManagerInfo(): AccountManagerInfo {
		// Ensure columns are arrays (defensive check)
		// If imports fail, provide minimal valid column arrays
		let orderCols: any[] = [];
		let positionCols: any[] = [];

		try {
			// Check if ordersPageColumns is available and valid
			if (typeof ordersPageColumns !== 'undefined' && Array.isArray(ordersPageColumns) && ordersPageColumns.length > 0) {
				// Validate each column has required fields
				orderCols = ordersPageColumns.filter(col =>
					col &&
					typeof col === 'object' &&
					Array.isArray(col.dataFields) &&
					col.id &&
					col.label
				);
				if (orderCols.length === 0) {
					throw new Error('No valid order columns found');
				}
			} else {
				throw new Error('ordersPageColumns is not available');
			}
		} catch (error) {
			console.warn('[ZuperiorBroker] Error loading order columns, using fallback:', error);
			// Fallback minimal columns if import fails
			orderCols = [
				{ label: 'Symbol', id: 'symbol', dataFields: ['symbol'], formatter: 'symbol' },
				{ label: 'Side', id: 'side', dataFields: ['side'], formatter: 'side' },
				{ label: 'Qty', id: 'qty', dataFields: ['qty'], formatter: 'formatQuantity' },
				{ label: 'Status', id: 'status', dataFields: ['status'], formatter: 'status' },
			];
		}

		try {
			// Check if positionsPageColumns is available and valid
			if (typeof positionsPageColumns !== 'undefined' && Array.isArray(positionsPageColumns) && positionsPageColumns.length > 0) {
				// Validate each column has required fields
				positionCols = positionsPageColumns.filter(col =>
					col &&
					typeof col === 'object' &&
					Array.isArray(col.dataFields) &&
					col.id &&
					col.label
				);
				if (positionCols.length === 0) {
					throw new Error('No valid position columns found');
				}
			} else {
				throw new Error('positionsPageColumns is not available');
			}
		} catch (error) {
			console.warn('[ZuperiorBroker] Error loading position columns, using fallback:', error);
			// Fallback minimal columns if import fails
			positionCols = [
				{ label: 'Symbol', id: 'symbol', dataFields: ['symbol'], formatter: 'symbol' },
				{ label: 'Side', id: 'side', dataFields: ['side'], formatter: 'side' },
				{ label: 'Qty', id: 'qty', dataFields: ['qty'], formatter: 'formatQuantity' },
				{ label: 'Avg Price', id: 'avgPrice', dataFields: ['avgPrice'], formatter: 'formatPrice' },
				{ label: 'Profit', id: 'pl', dataFields: ['pl'], formatter: 'profit' },
			];
		}

		const accountInfo: AccountManagerInfo = {
			accountTitle: 'Trading Account',
			summary: [],
			orderColumns: orderCols,
			positionColumns: positionCols,
			pages: [], // Required field - empty array if no custom pages
		};

		// Add custom formatters and columns as requested
		(accountInfo as any).customFormatters = [
			{
				name: 'custom-type',
				formatText: (dataFields: any) => {
					return dataFields.values[0];
				}
			},
			{
				name: 'custom-button',
				formatElement: (dataFields: any) => {
					const price = dataFields.values[0];
					const button = document.createElement('button');
					button.innerText = 'Alert';
					button.style.cursor = 'pointer';
					button.style.padding = '4px 8px';
					button.style.borderRadius = '4px';
					button.style.backgroundColor = '#2962FF';
					button.style.color = 'white';
					button.style.border = 'none';

					button.addEventListener('click', (event) => {
						event.stopPropagation();
						// Use safe host call or direct call if type allows
						if (this._host && typeof (this._host as any).showNotification === 'function') {
							(this._host as any).showNotification(
								'The button is clicked',
								`The price is: ${price}`,
								1
							);
						} else {
							alert(`The price is: ${price}`);
						}
					});

					return button;
				}
			}
		];

		// REMOVED: Custom and Button columns as requested
		// No custom columns will be added to match the open positions table

		console.log('[ZuperiorBroker] accountManagerInfo:', {
			orderColumnsCount: accountInfo.orderColumns.length,
			positionColumnsCount: accountInfo.positionColumns?.length || 0,
			pagesCount: accountInfo.pages.length,
		});

		return accountInfo;
	}

	public async accountsMetainfo(): Promise<AccountMetainfo[]> {
		return [
			{
				id: (this._accountId || '1') as AccountId,
				name: `Account ${this._accountId || '1'}`,
			},
		];
	}

	public async chartContextMenuActions(
		_context: TradeContext,
		_options?: DefaultContextMenuActionsParams | undefined
	): Promise<ActionMetaInfo[]> {
		return this._host.defaultContextMenuActions(_context);
	}

	public destroy() {
		if (this._pollInterval) {
			clearInterval(this._pollInterval);
			this._pollInterval = null;
		}
		this._isPolling = false;
	}

	// ============================================================================
	// Helper method to create clean position object for TradingView
	// ============================================================================
	private _createCleanPosition(position: Position): Position {
		// Create a clean position object with ALL fields expected by the app's position table
		// This ensures Account Manager displays the same data as the app's position table
		const clean: Position = {
			id: String(position.id),
			symbol: String(position.symbol).toUpperCase(),
			qty: Number(position.qty),
			side: Number(position.side),
			avgPrice: Number(position.avgPrice),
		} as Position;

		// Add ticket field (required by app's position table)
		if ((position as any).ticket !== undefined) {
			(clean as any).ticket = Number((position as any).ticket);
		}

		// Add type field as string (Buy/Sell) - required by app's position table
		if ((position as any).type !== undefined) {
			(clean as any).type = String((position as any).type);
		} else {
			// FIXED: Correct fallback mapping from side to type
			(clean as any).type = position.side === Side.Buy ? 'Buy' : 'Sell';
		}

		// Add volume field (alias for qty) - app uses 'volume'
		(clean as any).volume = Number(position.qty);

		// Add openPrice field (alias for avgPrice) - app uses 'openPrice'
		(clean as any).openPrice = Number(position.avgPrice);

		// Add currentPrice field - required for P&L calculation
		if ((position as any).currentPrice !== undefined) {
			(clean as any).currentPrice = Number((position as any).currentPrice);
		} else if ((position as any).last !== undefined) {
			(clean as any).currentPrice = Number((position as any).last);
		}

		// CRITICAL: Always include takeProfit and stopLoss fields (even if undefined)
		// TradingView needs these fields present to show TP/SL buttons on trade lines
		const takeProfitValue = (position.takeProfit !== undefined && position.takeProfit !== null && typeof position.takeProfit === 'number' && isFinite(position.takeProfit) && position.takeProfit > 0)
			? Number(position.takeProfit)
			: null; // Use null instead of undefined for TradingView brackets
		const stopLossValue = (position.stopLoss !== undefined && position.stopLoss !== null && typeof position.stopLoss === 'number' && isFinite(position.stopLoss) && position.stopLoss > 0)
			? Number(position.stopLoss)
			: null; // Use null instead of undefined for TradingView brackets

		// Explicitly assign to ensure they're enumerable properties
		clean.takeProfit = takeProfitValue;
		clean.stopLoss = stopLossValue;

		// Add profit field - required by app's position table
		if ((position as any).pl !== undefined && (position as any).pl !== null && typeof (position as any).pl === 'number' && isFinite((position as any).pl)) {
			(clean as any).pl = Number((position as any).pl);
			(clean as any).profit = Number((position as any).pl); // App uses 'profit'
		}

		// Add last (current price) field for TradingView
		if ((position as any).last !== undefined && (position as any).last !== null && typeof (position as any).last === 'number' && isFinite((position as any).last)) {
			(clean as any).last = Number((position as any).last);
		}

		// Add swap field - required by app's position table
		if ((position as any).swap !== undefined) {
			(clean as any).swap = Number((position as any).swap || 0);
		}

		// Add commission field - required by app's position table
		if ((position as any).commission !== undefined) {
			(clean as any).commission = Number((position as any).commission || 0);
		}

		// Add comment field - required by app's position table
		if ((position as any).comment !== undefined) {
			(clean as any).comment = String((position as any).comment);
		}

		// Add openTime field - required by app's position table
		if ((position as any).openTime !== undefined) {
			(clean as any).openTime = String((position as any).openTime);
		}

		// Add openTimeInMs field - required by TradingView for proper chart display
		if ((position as any).openTimeInMs !== undefined) {
			(clean as any).openTimeInMs = Number((position as any).openTimeInMs);
		} else if ((position as any).openTime !== undefined) {
			// Convert openTime string to milliseconds if openTimeInMs not available
			try {
				(clean as any).openTimeInMs = new Date((position as any).openTime).getTime();
			} catch (e) {
				(clean as any).openTimeInMs = Date.now();
			}
		}

		// Add positionId field - app uses this
		if ((position as any).positionId !== undefined) {
			(clean as any).positionId = Number((position as any).positionId);
		}

		return clean;
	}

	// ============================================================================
	// syncFromLiveState - Main method to sync positions/orders from parent component
	// ============================================================================
	public syncFromLiveState(openPositions: any[], pendingOrders: any[]): void {
		console.log('[ZuperiorBroker] syncFromLiveState called:', {
			positionsCount: (openPositions || []).length,
			ordersCount: (pendingOrders || []).length,
		});

		try {
			// 1) Process positions and create bracket orders
			for (const p of openPositions || []) {
				const id = String(p.ticket ?? p.id ?? '');
				if (!id) continue;
				const symbol = String(p.symbol ?? '');

				// FIXED: Correct side mapping to match open positions table
				const typeStr = String(p.type || '');
				const side: Side = typeStr === 'Buy' ? Side.Buy : Side.Sell;

				const rawVolume = Math.abs(Number(p.volume ?? p.qty ?? 0));
				// Divide by 10000 to match open positions table formatting
				const volume = rawVolume / 10000;
				const avgPrice = Number(p.openPrice ?? p.price ?? 0);

				if (volume <= 0 || avgPrice <= 0) continue;

				// FIXED: Extract TP/SL with better validation - only include positive values
				const stopLossRaw = p.stopLoss ?? p.StopLoss ?? p.SL ?? p.sl ??
					p.stop_loss ?? p.Stop_Loss ?? p.stopLossPrice ?? p.StopLossPrice ?? p.PriceSL ?? p.priceSL;
				const stopLossNum = (stopLossRaw !== undefined && stopLossRaw !== null && stopLossRaw !== '' && stopLossRaw !== 0)
					? (typeof stopLossRaw === 'string' ? parseFloat(stopLossRaw) : Number(stopLossRaw))
					: NaN;
				const stopLoss = Number.isFinite(stopLossNum) && stopLossNum > 0 ? stopLossNum : undefined;

				const takeProfitRaw = p.takeProfit ?? p.TakeProfit ?? p.TP ?? p.tp ??
					p.take_profit ?? p.Take_Profit ?? p.takeProfitPrice ?? p.TakeProfitPrice ?? p.PriceTP ?? p.priceTP;
				const takeProfitNum = (takeProfitRaw !== undefined && takeProfitRaw !== null && takeProfitRaw !== '' && takeProfitRaw !== 0)
					? (typeof takeProfitRaw === 'string' ? parseFloat(takeProfitRaw) : Number(takeProfitRaw))
					: NaN;
				const takeProfit = Number.isFinite(takeProfitNum) && takeProfitNum > 0 ? takeProfitNum : undefined;

				// Debug logging to see what we're getting from API
				if (id && (takeProfitRaw !== undefined || stopLossRaw !== undefined)) {
					console.log(`[ZuperiorBroker] syncFromLiveState TP/SL extraction for position ${id}:`, {
						takeProfitRaw,
						takeProfit,
						stopLossRaw,
						stopLoss,
						allPositionKeys: Object.keys(p),
					});
				}

				const position: Position = {
					id,
					symbol,
					qty: volume,
					side,
					avgPrice,
					price: avgPrice,
					updateTime: Date.now(),
				} as Position;

				// Handle P/L - check multiple field name variations
				const currentPriceValue = p.currentPrice && Number(p.currentPrice) > 0 ? Number(p.currentPrice) : undefined;
				if (currentPriceValue) {
					position.currentPrice = currentPriceValue;
					(position as any).last = currentPriceValue;

					// Check multiple field names for profit (pnl, profit, Profit, PL, pl)
					const profitRaw = p.pnl ?? p.PNL ?? p.profit ?? p.Profit ?? p.pl ?? p.PL;
					if (profitRaw !== undefined && profitRaw !== null) {
						const profitValue = typeof profitRaw === 'string' ? parseFloat(profitRaw) : Number(profitRaw);
						if (Number.isFinite(profitValue)) {
							// Don't multiply profit for trade lines - keep original value
							(position as any).pl = profitValue;
							(position as any).pnl = profitValue;
						}
					} else {
						// Calculate profit from price difference if not provided
						const priceDiff = (position as any).last - position.price;
						const plValue = priceDiff * position.qty * (side === Side.Sell ? -1 : 1);
						// Don't multiply profit for trade lines - keep calculated value
						(position as any).pl = plValue;
						(position as any).pnl = plValue;
					}
				} else {
					// Even without currentPrice, try to get profit from API
					const profitRaw = p.pnl ?? p.PNL ?? p.profit ?? p.Profit ?? p.pl ?? p.PL;
					if (profitRaw !== undefined && profitRaw !== null) {
						const profitValue = typeof profitRaw === 'string' ? parseFloat(profitRaw) : Number(profitRaw);
						if (Number.isFinite(profitValue)) {
							// Don't multiply profit for trade lines - keep original value
							(position as any).pl = profitValue;
							(position as any).pnl = profitValue;
						}
					}
				}


				// Set TP/SL fields on position object - use null for TradingView brackets
				position.takeProfit = takeProfit || null;
				position.stopLoss = stopLoss || null;

				// Add all additional fields required by app's position table
				// These fields are extracted from API response to match usePositions hook format

				// ticket field - required by app
				(position as any).ticket = Number(p.ticket) || 0;

				// type field as string (Buy/Sell) - required by app
				(position as any).type = side === Side.Buy ? 'Buy' : 'Sell';

				// volume field (alias for qty) - app uses 'volume'
				(position as any).volume = Number(volume);

				// openPrice field (alias for avgPrice) - app uses 'openPrice'
				(position as any).openPrice = Number(avgPrice);

				// currentPrice field - required for P&L calculation
				(position as any).currentPrice = Number(currentPriceValue);

				// swap field - required by app
				(position as any).swap = Number(p.swap || p.Swap || 0);

				// commission field - required by app
				(position as any).commission = Number(p.commission || p.Commission || 0);

				// comment field - required by app
				(position as any).comment = p.comment || p.Comment || undefined;

				// openTime field - required by app
				const openTime = p.openTime || p.OpenTime || p.TimeCreate || p.timeCreate ||
					p.TimeSetup || p.timeSetup || new Date().toISOString();
				(position as any).openTime = String(openTime);

				// positionId field - app uses this
				(position as any).positionId = Number(p.PositionId || p.positionId || p.ticket) || undefined;

				// Ensure bracket fields are always present (even if null) for TradingView
				if (!('stopLoss' in position)) {
					position.stopLoss = null;
				}
				if (!('takeProfit' in position)) {
					position.takeProfit = null;
				}

				// Validate bracket values are numbers
				if (position.stopLoss !== undefined && typeof position.stopLoss !== 'number') {
					console.warn('[ZuperiorBroker] stopLoss is not a number, converting:', position.stopLoss);
					position.stopLoss = Number(position.stopLoss);
					if (!Number.isFinite(position.stopLoss) || position.stopLoss <= 0) {
						position.stopLoss = undefined;
					}
				}
				if (position.takeProfit !== undefined && typeof position.takeProfit !== 'number') {
					console.warn('[ZuperiorBroker] takeProfit is not a number, converting:', position.takeProfit);
					position.takeProfit = Number(position.takeProfit);
					if (!Number.isFinite(position.takeProfit) || position.takeProfit <= 0) {
						position.takeProfit = undefined;
					}
				}

				// CRITICAL: Update position FIRST with brackets so TradingView can show TP/SL buttons
				// The position must have takeProfit/stopLoss fields set (even if undefined) for buttons to appear
				if (this._isWidgetReady) {
					const cleanPosition = this._createCleanPosition(position);

					// CRITICAL: Store clean position in _positionById BEFORE calling positionUpdate
					// TradingView may call positions() internally during positionUpdate, and it needs
					// to find the position in _positionById with the same structure
					this._positionById[id] = cleanPosition;

					// Debug: Log profit value after creating clean position
					console.log('[ZuperiorBroker] Position profit after clean:', {
						id: cleanPosition.id,
						cleanProfit: (cleanPosition as any).pl,
						profitType: typeof (cleanPosition as any).pl,
					});

					// Step 1: Update position with brackets FIRST
					safeHostCall(this._host, 'positionUpdate', cleanPosition);
					if ((cleanPosition as any).pl !== undefined && (cleanPosition as any).pl !== null) {
						const plValue = Number((cleanPosition as any).pl);
						console.log('[ZuperiorBroker] Calling plUpdate with profit:', plValue);
						safeHostCall(this._host, 'plUpdate', cleanPosition.symbol, plValue);
					}
					console.log('[ZuperiorBroker] Position updated with brackets:', {
						id: cleanPosition.id,
						symbol: cleanPosition.symbol,
						takeProfit: cleanPosition.takeProfit,
						stopLoss: cleanPosition.stopLoss,
						pl: (cleanPosition as any).pl,
						qty: cleanPosition.qty,
					});

					// Step 2: Create bracket orders AFTER position is updated
					// TradingView will match these to the position's brackets
					if (cleanPosition.takeProfit !== undefined && cleanPosition.takeProfit > 0) {
						try {
							const tpBracket = this._createTakeProfitBracket(cleanPosition);
							this._orderById[tpBracket.id] = tpBracket;
							safeHostCall(this._host, 'orderUpdate', tpBracket);
							console.log('[ZuperiorBroker] Created TP bracket order:', tpBracket.id, 'limitPrice:', tpBracket.limitPrice);
						} catch (error) {
							console.error('[ZuperiorBroker] Error creating TP bracket:', error);
						}
					}

					if (cleanPosition.stopLoss !== undefined && cleanPosition.stopLoss > 0) {
						try {
							const slBracket = this._createStopLossBracket(cleanPosition);
							this._orderById[slBracket.id] = slBracket;
							safeHostCall(this._host, 'orderUpdate', slBracket);
							console.log('[ZuperiorBroker] Created SL bracket order:', slBracket.id, 'stopPrice:', slBracket.stopPrice);
						} catch (error) {
							console.error('[ZuperiorBroker] Error creating SL bracket:', error);
						}
					}
				}
			}

			// 2) Process pending orders
			for (const o of pendingOrders || []) {
				const id = String(o.ticket ?? o.id ?? '');
				if (!id) continue;

				const symbol = String(o.symbol ?? '');
				const typeStr = String(o.type || '').toLowerCase();
				const side: Side = typeStr === 'sell' ? Side.Sell : Side.Buy;

				const rawVolume = Math.abs(Number(o.volume ?? 0));
				const volume = rawVolume; // Use raw volume

				const orderType = o.orderType || o.Type || o.type;
				let type: OrderType;
				if (typeof orderType === 'number') {
					if (orderType === 2 || orderType === 3) type = OrderType.Limit;
					else if (orderType === 4 || orderType === 5) type = OrderType.Stop;
					else type = OrderType.Market;
				} else {
					type = OrderType.Market;
				}

				const openPrice = Number(o.openPrice ?? o.price ?? 0);
				const limitPrice = (type === OrderType.Limit) ? openPrice : undefined;
				const stopPrice = (type === OrderType.Stop) ? openPrice : undefined;

				const order: Order = {
					id,
					symbol,
					qty: volume,
					side,
					type,
					status: OrderStatus.Working,
					limitPrice,
					stopPrice,
					takeProfit: o.takeProfit ?? o.TakeProfit ?? o.TP ?? o.tp ?? undefined,
					stopLoss: o.stopLoss ?? o.StopLoss ?? o.SL ?? o.sl ?? undefined,
				} as Order;

				this._orderById[id] = order;
				if (this._isWidgetReady) {
					safeHostCall(this._host, 'orderUpdate', order);
				}
			}

			// Update internal arrays
			this._positions.length = 0;
			this._positions.push(...Object.values(this._positionById));
			this._orders.length = 0;
			this._orders.push(...Object.values(this._orderById));

			console.log(`[ZuperiorBroker] syncFromLiveState completed: ${this._positions.length} positions, ${this._orders.length} orders`);
		} catch (error) {
			console.error('[ZuperiorBroker] Error in syncFromLiveState:', error);
		}
	}

	// ============================================================================
	// Bracket Creation Helper Methods
	// ============================================================================

	private _createTakeProfitBracket(entity: Position | Order): Order {
		if (!entity.symbol || typeof entity.symbol !== 'string' || entity.symbol.trim() === '') {
			throw new Error(`Invalid symbol for TP bracket: ${entity.symbol} (entity id: ${entity.id})`);
		}

		// Match reference implementation EXACTLY - no isPosition check, always Order/Inactive initially
		const bracket: Order = {
			symbol: entity.symbol.trim(),
			qty: entity.qty,
			id: `tp_${entity.id}`,
			parentId: entity.id,
			parentType: ParentType.Order, // Match reference - will be updated to Position later
			limitPrice: entity.takeProfit,
			side: changeSide(entity.side),
			status: OrderStatus.Inactive, // Match reference - will be updated to Working later
			type: OrderType.Limit,
		} as Order;

		return bracket;
	}

	private _createStopLossBracket(entity: Position | Order): Order {
		if (!entity.symbol || typeof entity.symbol !== 'string' || entity.symbol.trim() === '') {
			throw new Error(`Invalid symbol for SL bracket: ${entity.symbol} (entity id: ${entity.id})`);
		}

		// Match reference implementation EXACTLY - no validation, just use the values directly
		// Reference: stopPrice: entity.stopLoss, price: entity.stopPrice
		// For positions, we set stopPrice = stopLoss before calling this method
		// CRITICAL: Reference uses entity.stopPrice for price field - must match exactly
		// If stopPrice is not set, use stopLoss as fallback to ensure price is always defined
		const stopPriceValue = entity.stopLoss;
		const priceValue = (entity as any).stopPrice !== undefined && (entity as any).stopPrice !== null
			? (entity as any).stopPrice
			: stopPriceValue; // Fallback to stopLoss if stopPrice not set

		const bracket: Order = {
			symbol: entity.symbol.trim(),
			qty: entity.qty,
			id: `sl_${entity.id}`,
			parentId: entity.id,
			parentType: ParentType.Order, // Match reference - will be updated to Position later
			stopPrice: stopPriceValue, // Match reference exactly - no Number() conversion
			price: priceValue, // Match reference exactly - uses entity.stopPrice with fallback to stopLoss
			side: changeSide(entity.side),
			status: OrderStatus.Inactive, // Match reference - will be updated to Working later
			type: OrderType.Stop,
		} as Order;

		// CRITICAL FIX: Ensure price is ALWAYS a valid number - TradingView needs this for notifications and chart line
		// Even if entity.stopPrice was set, double-check and ensure price is valid
		if ((bracket as any).price === undefined || (bracket as any).price === null || !Number.isFinite((bracket as any).price)) {
			(bracket as any).price = bracket.stopPrice;
		}

		return bracket;
	}

	private _getBrackets(parentId: string): Order[] {
	return Object.values(this._orderById).filter(
		(order: Order) => order.parentId === parentId &&
			(order.status === OrderStatus.Working || order.status === OrderStatus.Inactive)
	);
}

	private _getTakeProfitBracket(entity: Position | Order): Order | undefined {
	return this._getBrackets(entity.id).find((bracket: Order) => bracket.limitPrice !== undefined);
}

	private _getStopLossBracket(entity: Position | Order): Order | undefined {
	return this._getBrackets(entity.id).find((bracket: Order) => bracket.stopPrice !== undefined);
}

	private _updateOrder(order: Order): void {
	const hasOrderAlready = Boolean(this._orderById[order.id]);

	if(hasOrderAlready) {
		Object.assign(this._orderById[order.id], order);
	} else {
		this._orderById[order.id] = order;
	}

		// Update orders array
		const orderIndex = this._orders.findIndex(o => o.id === order.id);
	if(orderIndex >= 0) {
	this._orders[orderIndex] = order;
} else {
	this._orders.push(order);
}

// Notify TradingView
if (this._host && typeof this._host.orderUpdate === 'function') {
	this._host.orderUpdate(order);
}

// Update parent entity's brackets if applicable
if (order.parentId !== undefined) {
	const entity = order.parentType === ParentType.Position
		? this._positionById[order.parentId]
		: this._orderById[order.parentId];

	if (entity === undefined) {
		return;
	}

	// Update take-profit
	if (order.limitPrice !== undefined) {
		(entity as any).takeProfit = order.status !== OrderStatus.Canceled
			? order.limitPrice
			: undefined;
	}

	// Update stop-loss
	if (order.stopPrice !== undefined) {
		(entity as any).stopLoss = order.status !== OrderStatus.Canceled
			? order.stopPrice
			: undefined;
	}

	// If parent is a position, update it
	if (order.parentType === ParentType.Position && entity) {
		if (this._host && typeof this._host.positionUpdate === 'function') {
			const cleanPosition = this._createCleanPosition(entity as Position);
			// Update _positionById with clean position before calling positionUpdate
			this._positionById[cleanPosition.id] = cleanPosition;
			this._host.positionUpdate(cleanPosition);
		}
	}
}
	}

	private _setCanceledStatusAndUpdate(order: Order): void {
	order.status = OrderStatus.Canceled;
	this._updateOrder(order);
}

	private _updatePositionsBracket(params: {
	parent: Position;
	bracket: Order | undefined;
	bracketType: 0 | 1; // 0 = StopLoss, 1 = TakeProfit
	newPrice: number | undefined;
}): void {
	const { parent, bracket, bracketType, newPrice } = params;

	// Check if bracket should be canceled
	const shouldCancelBracket = bracket !== undefined && newPrice === undefined;
	if(shouldCancelBracket) {
		this._setCanceledStatusAndUpdate(bracket);
		return;
	}

		if(newPrice === undefined) {
	return;
}

const shouldCreateNewBracket = bracket === undefined;

// Handle Take Profit
if (bracketType === 1) {
	if (shouldCreateNewBracket) {
		// Set parent.takeProfit BEFORE creating bracket
		parent.takeProfit = newPrice;
		const takeProfitBracket = this._createTakeProfitBracket(parent);
		takeProfitBracket.status = OrderStatus.Working;
		takeProfitBracket.parentType = ParentType.Position;

		if (!takeProfitBracket.symbol || takeProfitBracket.symbol.trim() === '') {
			console.error('[ZuperiorBroker] Cannot create TP bracket - invalid symbol');
			return;
		}

		try {
			this._updateOrder(takeProfitBracket);
			// Update parent position after bracket is created
			if (this._host && typeof this._host.positionUpdate === 'function') {
				const cleanPosition = this._createCleanPosition(parent);
				// Update _positionById with clean position before calling positionUpdate
				this._positionById[cleanPosition.id] = cleanPosition;
				this._host.positionUpdate(cleanPosition);
			}
		} catch (error) {
			console.error('[ZuperiorBroker] Error creating TP bracket:', error);
		}
		return;
	}

	// Update existing bracket
	bracket.limitPrice = newPrice;
	// Also update parent position's takeProfit to match
	parent.takeProfit = newPrice;
	if (!bracket.symbol || bracket.symbol.trim() === '') {
		console.error('[ZuperiorBroker] Cannot update TP bracket - invalid symbol');
		return;
	}

	try {
		this._updateOrder(bracket);
		// Update parent position after bracket is updated
		if (this._host && typeof this._host.positionUpdate === 'function') {
			const cleanPosition = this._createCleanPosition(parent);
			// Update _positionById with clean position before calling positionUpdate
			this._positionById[cleanPosition.id] = cleanPosition;
			this._host.positionUpdate(cleanPosition);
		}
	} catch (error) {
		console.error('[ZuperiorBroker] Error updating TP bracket:', error);
	}
	return;
}

// Handle Stop Loss
if (bracketType === 0) {
	if (shouldCreateNewBracket) {
		// Set parent.stopLoss BEFORE creating bracket
		parent.stopLoss = newPrice;
		const stopLossBracket = this._createStopLossBracket(parent);
		stopLossBracket.status = OrderStatus.Working;
		stopLossBracket.parentType = ParentType.Position;

		if (!stopLossBracket.symbol || stopLossBracket.symbol.trim() === '') {
			console.error('[ZuperiorBroker] Cannot create SL bracket - invalid symbol');
			return;
		}

		try {
			this._updateOrder(stopLossBracket);
		} catch (error) {
			console.error('[ZuperiorBroker] Error creating SL bracket:', error);
		}
		return;
	}

	// Update existing bracket
	bracket.stopPrice = newPrice;
	// Also update parent position's stopLoss to match
	parent.stopLoss = newPrice;
	if (!bracket.symbol || bracket.symbol.trim() === '') {
		console.error('[ZuperiorBroker] Cannot update SL bracket - invalid symbol');
		return;
	}

	try {
		this._updateOrder(bracket);
		// Update parent position after bracket is updated
		if (this._host && typeof this._host.positionUpdate === 'function') {
			const cleanPosition = this._createCleanPosition(parent);
			// Update _positionById with clean position before calling positionUpdate
			this._positionById[cleanPosition.id] = cleanPosition;
			this._host.positionUpdate(cleanPosition);
		}
	} catch (error) {
		console.error('[ZuperiorBroker] Error updating SL bracket:', error);
	}
	return;
}
	}
}
